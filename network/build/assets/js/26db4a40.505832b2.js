"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[1356],{39516:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var t=s(49214),o=s(43540);const i={tags:["Lux Consensus","Lux Protocol"],description:"Lux Consensus is a consensus protocol that is scalable, robust, and decentralized.",keywords:["lux consensus","snowman consensus","scaling blockchains","nakamoto consensus"],sidebar_label:"Lux Consensus"},a="Lux Consensus",r={id:"learn/lux/lux-consensus",title:"Lux Consensus",description:"Lux Consensus is a consensus protocol that is scalable, robust, and decentralized.",source:"@site/docs/learn/lux/lux-consensus.md",sourceDirName:"learn/lux",slug:"/learn/lux/lux-consensus",permalink:"/docs/learn/lux/lux-consensus",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/learn/lux/lux-consensus.md",tags:[{label:"Lux Consensus",permalink:"/docs/tags/lux-consensus"},{label:"Lux Protocol",permalink:"/docs/tags/lux-protocol"}],version:"current",frontMatter:{tags:["Lux Consensus","Lux Protocol"],description:"Lux Consensus is a consensus protocol that is scalable, robust, and decentralized.",keywords:["lux consensus","snowman consensus","scaling blockchains","nakamoto consensus"],sidebar_label:"Lux Consensus"},sidebar:"learn",previous:{title:"Testnet",permalink:"/docs/learn/lux/testnet"},next:{title:"Subnets",permalink:"/docs/learn/lux/subnets-overview"}},c={},l=[{value:"Conceptual Overview",id:"conceptual-overview",level:2},{value:"Deep Dive Into Lux Consensus",id:"deep-dive-into-lux-consensus",level:2},{value:"Intuition",id:"intuition",level:3},{value:"Snowball",id:"snowball",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"Algorithm Explained",id:"algorithm-explained",level:4},{value:"Blocks",id:"blocks",level:3},{value:"Finality",id:"finality",level:3},{value:"Optimizations",id:"optimizations",level:3},{value:"Validators",id:"validators",level:3},{value:"Big Ideas",id:"big-ideas",level:3},{value:"Loose Ends",id:"loose-ends",level:3},{value:"Other Observations",id:"other-observations",level:3},{value:"Why Do We Care?",id:"why-do-we-care",level:2},{value:"Summary",id:"summary",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"lux-consensus",children:"Lux Consensus"}),"\n",(0,t.jsx)(n.p,{children:"Consensus is the task of getting a group of computers (a.k.a. nodes) to come to an agreement on a decision.\nIn blockchain, this means that all the participants in a network have to agree on the changes made to\nthe shared ledger. This agreement is reached through a specific process, a consensus protocol,\nthat ensures that everyone sees the same information and that the information is accurate and trustworthy."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Lux Consensus"})," is a consensus protocol that is scalable, robust, and decentralized. It\ncombines features of both classical and Nakamoto consensus mechanisms to achieve high throughput,\nfast finality, and\nenergy efficiency. For the whitepaper, see ",(0,t.jsx)(n.a,{href:"https://www.lux.network/whitepapers",children:"here"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Key Features Include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Speed: Lux consensus provides sub-second, immutable finality, ensuring that transactions are\nquickly confirmed and irreversible."}),"\n",(0,t.jsx)(n.li,{children:"Scalability: Lux consensus enables high network throughput while ensuring low latency."}),"\n",(0,t.jsx)(n.li,{children:"Energy Efficiency: Unlike other popular consensus protocols, participation in Lux consensus\nis neither computationally intensive nor expensive."}),"\n",(0,t.jsx)(n.li,{children:"Adaptive Security: Lux consensus is designed to resist various attacks, including sybil\nattacks, distributed denial-of-service (DDoS) attacks, and collusion attacks. Its probabilistic\nnature ensures that the consensus outcome converges to the desired state, even when the network\nis under attack."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conceptual-overview",children:"Conceptual Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Consensus protocols in the Lux family operate through repeated sub-sampled voting. When a\nnode is determining whether a\n",(0,t.jsx)(n.a,{href:"http://support.lux.network/en/articles/4587384-what-is-a-transaction",children:"transaction"})," should be\naccepted, it asks a small, random subset of\n",(0,t.jsx)(n.a,{href:"http://support.lux.network/en/articles/4064704-what-is-a-blockchain-validator",children:"validator nodes"}),"\nfor their preference. Each queried validator replies with the transaction that it prefers, or thinks\nshould be accepted."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Consensus will never include a transaction that is determined to be ",(0,t.jsx)(n.strong,{children:"invalid"}),". For example, if you\nwere to submit a transaction to send 100 LUX to a friend, but your wallet only has 2 LUX, this transaction\nis considered ",(0,t.jsx)(n.strong,{children:"invalid"})," and will not participate in consensus."]})}),"\n",(0,t.jsx)(n.p,{children:"If a sufficient majority of the validators sampled reply with the same preferred\ntransaction, this becomes the preferred choice of the validator that inquired."}),"\n",(0,t.jsx)(n.p,{children:"In the future, this node will reply with the transaction preferred by the majority."}),"\n",(0,t.jsx)(n.p,{children:"The node repeats this sampling process until the validators\nqueried reply with the same answer for a sufficient number of consecutive rounds."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['The number of validators required to be considered a "sufficient majority" is referred to as "\u03b1" (',(0,t.jsx)(n.em,{children:"alpha"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:['The number of consecutive rounds required to reach consensus, a.k.a. the "Confidence Threshold,"\nis referred to as "\u03b2" (',(0,t.jsx)(n.em,{children:"beta"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"Both \u03b1 and \u03b2 are configurable."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When a transaction has no conflicts, finalization happens very quickly. When\nconflicts exist, honest validators quickly cluster around conflicting transactions, entering a\npositive feedback loop until all correct validators prefer that transaction. This leads to the\nacceptance of non-conflicting transactions and the rejection of conflicting transactions."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"How Lux Consensus Works",src:s(72984).A+"",width:"4097",height:"2049"})}),"\n",(0,t.jsx)(n.p,{children:"Lux Consensus guarantees that if any honest validator accepts a transaction,\nall honest validators will come to the same conclusion."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["For a great visualization, check out ",(0,t.jsx)(n.a,{href:"https://tedyin.com/archive/snow-bft-demo/#/snow",children:"this demo"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"deep-dive-into-lux-consensus",children:"Deep Dive Into Lux Consensus"}),"\n",(0,t.jsx)("iframe",{src:"https://www.youtube.com/embed/ZUF9sIu-D_k",width:"100%",height:"480px",title:"Deep Dive on the Lux Protocol",className:"video-container",display:"initial",position:"relative",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",(0,t.jsx)(n.h3,{id:"intuition",children:"Intuition"}),"\n",(0,t.jsxs)(n.p,{children:["First, let's develop some intuition about the protocol. Imagine a room full of people trying to\nagree on what to get for lunch. Suppose it's a binary choice between pizza and barbecue. Some people\nmight initially prefer pizza while others initially prefer barbecue. Ultimately, though, everyone's\ngoal is to achieve ",(0,t.jsx)(n.strong,{children:"consensus"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:['Everyone asks a random subset of the people in the room what their lunch preference is. If more than\nhalf say pizza, the person thinks, "OK, looks like things are leaning toward pizza. I prefer pizza\nnow." That is, they adopt the ',(0,t.jsx)(n.em,{children:"preference"})," of the majority. Similarly, if a majority say barbecue,\nthe person adopts barbecue as their preference."]}),"\n",(0,t.jsx)(n.p,{children:"Everyone repeats this process. Each round, more and more people have the same preference. This is\nbecause the more people that prefer an option, the more likely someone is to receive a majority\nreply and adopt that option as their preference. After enough rounds, they reach consensus and\ndecide on one option, which everyone prefers."}),"\n",(0,t.jsx)(n.h3,{id:"snowball",children:"Snowball"}),"\n",(0,t.jsx)(n.p,{children:"The intuition above outlines the Snowball Algorithm, which is a building block of Lux\nconsensus. Let's review the Snowball algorithm."}),"\n",(0,t.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"n"}),": number of participants"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"k"})," (sample size): between 1 and ",(0,t.jsx)(n.em,{children:"n"})]}),"\n",(0,t.jsxs)(n.li,{children:["\u03b1 (quorum size): between 1 and ",(0,t.jsx)(n.em,{children:"k"})]}),"\n",(0,t.jsx)(n.li,{children:"\u03b2 (decision threshold): >= 1"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"algorithm",children:"Algorithm"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"preference := pizza\nconsecutiveSuccesses := 0\nwhile not decided:\n  ask k random people their preference\n  if >= \u03b1 give the same response:\n    preference := response with >= \u03b1\n    if preference == old preference:\n      consecutiveSuccesses++\n    else:\n      consecutiveSuccesses = 1\n  else:\n    consecutiveSuccesses = 0\n  if consecutiveSuccesses > \u03b2:\n    decide(preference)\n"})}),"\n",(0,t.jsx)(n.h4,{id:"algorithm-explained",children:"Algorithm Explained"}),"\n",(0,t.jsxs)(n.p,{children:["Everyone has an initial preference for pizza or barbecue. Until someone has ",(0,t.jsx)(n.em,{children:"decided"}),", they query\n",(0,t.jsx)(n.em,{children:"k"})," people (the sample size) and ask them what they prefer. If \u03b1 or more people give the same\nresponse, that response is adopted as the new preference. \u03b1 is called the ",(0,t.jsx)(n.em,{children:"quorum size"}),". If the new\npreference is the same as the old preference, the ",(0,t.jsx)(n.code,{children:"consecutiveSuccesses"})," counter is incremented. If\nthe new preference is different then the old preference, the ",(0,t.jsx)(n.code,{children:"consecutiveSuccesses"})," counter is set\nto ",(0,t.jsx)(n.code,{children:"1"}),". If no response gets a quorum (an \u03b1 majority of the same response) then the\n",(0,t.jsx)(n.code,{children:"consecutiveSuccesses"})," counter is set to ",(0,t.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Everyone repeats this until they get a quorum for the same response \u03b2 times in a row. If one person\ndecides pizza, then every other person following the protocol will eventually also decide on pizza."}),"\n",(0,t.jsx)(n.p,{children:"Random changes in preference, caused by random sampling, cause a network preference for one choice,\nwhich begets more network preference for that choice until it becomes irreversible and then the\nnodes can decide."}),"\n",(0,t.jsx)(n.p,{children:"In our example, there is a binary choice between pizza or barbecue, but Snowball can be adapted to\nachieve consensus on decisions with many possible choices."}),"\n",(0,t.jsx)(n.p,{children:"The liveness and safety thresholds are parameterizable. As the quorum size, \u03b1, increases, the safety\nthreshold increases, and the liveness threshold decreases. This means the network can tolerate more\nbyzantine (deliberately incorrect, malicious) nodes and remain safe, meaning all nodes will\neventually agree whether something is accepted or rejected. The liveness threshold is the number of\nmalicious participants that can be tolerated before the protocol is unable to make progress."}),"\n",(0,t.jsxs)(n.p,{children:["These values, which are constants, are quite small on the Lux Network. The sample size, ",(0,t.jsx)(n.em,{children:"k"}),",\nis ",(0,t.jsx)(n.code,{children:"20"}),". So when a node asks a group of nodes their opinion, it only queries ",(0,t.jsx)(n.code,{children:"20"})," nodes out of the\nwhole network. The quorum size, \u03b1, is ",(0,t.jsx)(n.code,{children:"14"}),". So if ",(0,t.jsx)(n.code,{children:"14"})," or more nodes give the same response, that\nresponse is adopted as the querying node's preference. The decision threshold, \u03b2, is ",(0,t.jsx)(n.code,{children:"20"}),". A node\ndecides on choice after receiving ",(0,t.jsx)(n.code,{children:"20"})," consecutive quorum (\u03b1 majority) responses."]}),"\n",(0,t.jsxs)(n.p,{children:["Snowball is very scalable as the number of nodes on the network, ",(0,t.jsx)(n.em,{children:"n"}),", increases. Regardless of the\nnumber of participants in the network, the number of consensus messages sent remains the same\nbecause in a given query, a node only queries ",(0,t.jsx)(n.code,{children:"20"})," nodes, even if there are thousands of nodes in\nthe network."]}),"\n",(0,t.jsxs)(n.p,{children:["Everything discussed to this point is how Lux is described in ",(0,t.jsx)(n.a,{href:"https://assets-global.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Lux%20Consensus%20Whitepaper.pdf",children:"the Lux\nwhite-paper"}),".\nThe implementation of the Lux consensus protocol by Lux Partners (namely in Luxd) has some\noptimizations for latency and throughput."]}),"\n",(0,t.jsx)(n.h3,{id:"blocks",children:"Blocks"}),"\n",(0,t.jsx)(n.p,{children:'A block is a fundamental component that forms the structure of a blockchain. It serves as a container\nor data structure that holds a collection of transactions or other relevant information. Each block\nis cryptographically linked to the previous block, creating a chain of blocks, hence the term "blockchain."'}),"\n",(0,t.jsx)(n.p,{children:"In addition to storing a reference of its parent, a block contains a set of transactions. These\ntransactions can represent various types of information, such as financial transactions, smart\ncontract operations, or data storage requests."}),"\n",(0,t.jsx)(n.p,{children:"If a node receives a vote for a block, it also counts as a vote for all of the block's ancestors\n(its parent, the parents' parent, etc.)."}),"\n",(0,t.jsx)(n.h3,{id:"finality",children:"Finality"}),"\n",(0,t.jsxs)(n.p,{children:["Lux consensus is probabilistically safe up to a safety threshold. That is, the probability\nthat a correct node accepts a transaction that another correct node rejects can be made arbitrarily\nlow by adjusting system parameters. In Nakamoto consensus protocol (as used in Bitcoin and Ethereum,\nfor example), a block may be included in the chain but then be removed and not end up in the\ncanonical chain. This means waiting an hour for transaction settlement. In Lux,\nacceptance/rejection are ",(0,t.jsx)(n.strong,{children:"final and irreversible"})," and only take a few seconds."]}),"\n",(0,t.jsx)(n.h3,{id:"optimizations",children:"Optimizations"}),"\n",(0,t.jsx)(n.p,{children:'It\'s not safe for nodes to just ask, "Do you prefer this block?" when they query validators.\nIn Lux Partners\' implementation, during a query a node asks, "Given that this block exists, which\nblock do you prefer?" Instead of getting back a binary yes/no, the node receives the other\nnode\'s preferred block.'}),"\n",(0,t.jsx)(n.p,{children:"Nodes don't only query upon hearing of a new block; they repeatedly query other nodes until there are\nno blocks processing."}),"\n",(0,t.jsxs)(n.p,{children:["Nodes may not need to wait until they get all ",(0,t.jsx)(n.em,{children:"k"})," query responses before registering the outcome of a\npoll. If a block has already received ",(0,t.jsx)(n.em,{children:"alpha"})," votes, then there's no need to wait for the rest of the\nresponses."]}),"\n",(0,t.jsx)(n.h3,{id:"validators",children:"Validators"}),"\n",(0,t.jsx)(n.p,{children:"If it were free to become a validator on the Lux network, that would be problematic because a\nmalicious actor could start many, many nodes which would get queried very frequently. The malicious\nactor could make the node act badly and cause a safety or liveness failure. The validators, the\nnodes which are queried as part of consensus, have influence over the network. They have to pay for\nthat influence with real-world value in order to prevent this kind of ballot stuffing. This idea of\nusing real-world value to buy influence over the network is called Proof of Stake."}),"\n",(0,t.jsxs)(n.p,{children:["To become a validator, a node must ",(0,t.jsx)(n.strong,{children:"bond"})," (stake) something valuable (",(0,t.jsx)(n.strong,{children:"LUX"}),"). The more LUX a\nnode bonds, the more often that node is queried by other nodes. When a node samples the network it's\nnot uniformly random. Rather, it's weighted by stake amount. Nodes are incentivized to be validators\nbecause they get a reward if, while they validate, they're sufficiently correct and responsive."]}),"\n",(0,t.jsx)(n.p,{children:"Lux doesn't have slashing. If a node doesn't behave well while validating, such as giving\nincorrect responses or perhaps not responding at all, its stake is still returned in whole, but with\nno reward. As long as a sufficient portion of the bonded LUX is held by correct nodes, then the\nnetwork is safe, and is live for virtuous transactions."}),"\n",(0,t.jsx)(n.h3,{id:"big-ideas",children:"Big Ideas"}),"\n",(0,t.jsxs)(n.p,{children:["Two big ideas in Lux are ",(0,t.jsx)(n.strong,{children:"subsampling"})," and ",(0,t.jsx)(n.strong,{children:"transitive voting"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Subsampling has low message overhead. It doesn't matter if there are twenty validators or two\nthousand validators; the number of consensus messages a node sends during a query remains constant."}),"\n",(0,t.jsx)(n.p,{children:"Transitive voting, where a vote for a block is a vote for all its ancestors, helps with transaction\nthroughput. Each vote is actually many votes in one."}),"\n",(0,t.jsx)(n.h3,{id:"loose-ends",children:"Loose Ends"}),"\n",(0,t.jsxs)(n.p,{children:["Transactions are created by users which call an API on an\n",(0,t.jsx)(n.a,{href:"https://github.com/luxfi/luxd",children:"Luxd"})," full node or create them using a library such\nas ",(0,t.jsx)(n.a,{href:"https://github.com/luxfi/luxjs",children:"LuxJS"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"other-observations",children:"Other Observations"}),"\n",(0,t.jsx)(n.p,{children:"Conflicting transactions are not guaranteed to be live. That's not really a problem because if you\nwant your transaction to be live then you should not issue a conflicting transaction."}),"\n",(0,t.jsx)(n.p,{children:"Snowman is the name of Lux Partners' implementation of the Lux consensus protocol\nfor linear chains."}),"\n",(0,t.jsxs)(n.p,{children:["If there are no undecided transactions, the Lux consensus protocol ",(0,t.jsx)(n.em,{children:"quiesces"}),". That is, it does\nnothing if there is no work to be done. This makes Lux more sustainable than Proof-of-work\nwhere nodes need to constantly do work."]}),"\n",(0,t.jsx)(n.p,{children:"Lux has no leader. Any node can propose a transaction and any node that has staked LUX can\nvote on every transaction, which makes the network more robust and decentralized."}),"\n",(0,t.jsx)(n.h2,{id:"why-do-we-care",children:"Why Do We Care?"}),"\n",(0,t.jsx)(n.p,{children:"Lux is a general consensus engine. It doesn't matter what type of application is put on top of\nit. The protocol allows the decoupling of the application layer from the consensus layer. If you're\nbuilding a dapp on Lux then you just need to define a few things, like how conflicts are\ndefined and what is in a transaction. You don't need to worry about how nodes come to an agreement.\nThe consensus protocol is a black box that put something into it and it comes back as accepted or\nrejected."}),"\n",(0,t.jsx)(n.p,{children:"Lux can be used for all kinds of applications, not just P2P payment networks. Lux's\nPrimary Network has an instance of the Ethereum Virtual Machine, which is backward compatible with\nexisting Ethereum Dapps and dev tooling. The Ethereum consensus protocol has been replaced with\nLux consensus to enable lower block latency and higher throughput."}),"\n",(0,t.jsx)(n.p,{children:"Lux is very performant. It can process thousands of transactions per second with one to two\nsecond acceptance latency."}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Lux consensus is a radical breakthrough in distributed systems. It represents as large a leap\nforward as the classical and Nakamoto consensus protocols that came before it. Now that you have a\nbetter understanding of how it works, check out other documentations for building game-changing\nDapps and financial instruments on Lux."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},72984:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/howluxconsensusworks-9c508bbd5209ebd994105e591524b84e.png"},43540:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var t=s(48318);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[6206],{97508:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var t=s(49214),o=s(43540);const i={},a="Flow of a Single Blockchain",r={id:"reference/standards/guides/blockchain-flow",title:"Flow of a Single Blockchain",description:"Blockchain Flow",source:"@site/docs/reference/standards/guides/blockchain-flow.md",sourceDirName:"reference/standards/guides",slug:"/reference/standards/guides/blockchain-flow",permalink:"/docs/reference/standards/guides/blockchain-flow",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/reference/standards/guides/blockchain-flow.md",tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Banff Changes",permalink:"/docs/reference/standards/guides/banff-changes"}},c={},d=[{value:"Intro",id:"intro",level:2},{value:"Peer-to-Peer (P2P)",id:"peer-to-peer-p2p",level:2},{value:"Outbound Messages",id:"outbound-messages",level:3},{value:"Network",id:"network",level:3},{value:"Router",id:"router",level:2},{value:"Handler",id:"handler",level:2},{value:"Sender",id:"sender",level:2},{value:"Consensus Engine",id:"consensus-engine",level:2},{value:"Blockchain Creation",id:"blockchain-creation",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"flow-of-a-single-blockchain",children:"Flow of a Single Blockchain"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Blockchain Flow",src:s(51361).A+"",width:"1634",height:"586"})}),"\n",(0,t.jsx)(n.h2,{id:"intro",children:"Intro"}),"\n",(0,t.jsx)(n.p,{children:"The Lux network consists of 3 built-in blockchains: X-Chain, C-Chain, and\nP-Chain. The X-Chain is used to manage assets and uses the Lux consensus\nprotocol. The C-Chain is used to create and interact with smart contracts and\nuses the Snowman consensus protocol. The P-Chain is used to coordinate\nvalidators and stake and also uses the Snowman consensus protocol. At the time\nof writing, the Lux network has ~1200 validators. A set of validators\nmakes up a Subnet. Subnets can validate 1 or more chains. It is a common\nmisconception that 1 Subnet = 1 chain and this is shown by the primary Subnet of\nLux which is made up of the X-Chain, C-Chain, and P-Chain."}),"\n",(0,t.jsx)(n.p,{children:"A node in the Lux network can either be a validator or a non-validator. A\nvalidator stakes LUX tokens and participates in consensus to earn rewards. A\nnon-validator does not participate in consensus or have any LUX staked but can\nbe used as an API server. Both validators and non-validators need to have their\nown copy of the chain and need to know the current state of the network. At the\ntime of writing, there are ~1200 validators and ~1800 non-validators."}),"\n",(0,t.jsx)(n.p,{children:"Each blockchain on Lux has several components: the virtual machine,\ndatabase, consensus engine, sender, and handler. These components help the chain\nrun smoothly. Blockchains also interact with the P2P layer and the chain router\nto send and receive messages."}),"\n",(0,t.jsx)(n.h2,{id:"peer-to-peer-p2p",children:"Peer-to-Peer (P2P)"}),"\n",(0,t.jsx)(n.h3,{id:"outbound-messages",children:"Outbound Messages"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/message/outbound_msg_builder.go",children:["The ",(0,t.jsx)(n.code,{children:"OutboundMsgBuilder"}),"\ninterface"]}),"\nspecifies methods that build messages of type ",(0,t.jsx)(n.code,{children:"OutboundMessage"}),". Nodes\ncommunicate to other nodes by sending ",(0,t.jsx)(n.code,{children:"OutboundMessage"})," messages."]}),"\n",(0,t.jsxs)(n.p,{children:["All messaging functions in ",(0,t.jsx)(n.code,{children:"OutboundMsgBuilder"})," can be categorized as follows:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handshake"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Nodes need to be on a certain version before they can be accepted into the network."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Sync"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A new node can ask other nodes for the current state of the network. It only\nsyncs the required state for a specific block."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bootstrapping"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Nodes can ask other nodes for blocks to build their own copy of the chain. A\nnode can fetch all blocks from the locally last accepted block to the\ncurrent last accepted block in the network."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consensus"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Once a node is up to tip they can participate in consensus! During\nconsensus, a node conducts a poll to several different small random samples\nof the validator set. They can communicate decisions on whether or not they\nhave accepted/rejected a block."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"App"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"VMs communicate application-specific messages to other nodes through app\nmessages. A common example is mempool gossiping."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Currently, Luxd implements its own message serialization to communicate.\nIn the future, Luxd will use protocol buffers to communicate."}),"\n",(0,t.jsx)(n.h3,{id:"network",children:"Network"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/network/network.go",children:"The networking\ninterface"}),"\nis shared across all chains. It implements functions from the ",(0,t.jsx)(n.code,{children:"ExternalSender"}),"\ninterface. The two functions it implements are ",(0,t.jsx)(n.code,{children:"Send"})," and ",(0,t.jsx)(n.code,{children:"Gossip"}),". ",(0,t.jsx)(n.code,{children:"Send"})," sends\na message of type ",(0,t.jsx)(n.code,{children:"OutboundMessage"})," to a specific set of nodes (specified by an\narray of ",(0,t.jsx)(n.code,{children:"NodeIDs"}),"). ",(0,t.jsx)(n.code,{children:"Gossip"})," sends a message of type ",(0,t.jsx)(n.code,{children:"OutboundMessage"})," to a\nrandom group of nodes in a Subnet (can be a validator or a non-validator).\nGossiping is used to push transactions across the network. The networking\nprotocol uses TLS to pass messages between peers."]}),"\n",(0,t.jsx)(n.p,{children:"Along with sending and gossiping, the networking library is also responsible for\nmaking connections and maintaining connections. Any node, either a validator or\nnon-validator, will attempt to connect to the primary network."}),"\n",(0,t.jsx)(n.h2,{id:"router",children:"Router"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/networking/router/chain_router.go",children:["The\n",(0,t.jsx)(n.code,{children:"ChainRouter"})]}),"\nroutes all incoming messages to its respective blockchain using ",(0,t.jsx)(n.code,{children:"ChainID"}),". It\ndoes this by pushing all the messages onto the respective Chain handler\u2019s queue.\nThe ",(0,t.jsx)(n.code,{children:"ChainRouter"})," references all existing chains on the network such as the\nX-chain, C-chain, P-chain and possibly any other chain. The ",(0,t.jsx)(n.code,{children:"ChainRouter"}),"\nhandles timeouts as well. When sending messages on the P2P layer, timeouts are\nregistered on the sender and cleared on the ",(0,t.jsx)(n.code,{children:"ChainRouter"})," side when a response\nis received. If no response is received, then it triggers a timeout. Because\ntimeouts are handled on the ",(0,t.jsx)(n.code,{children:"ChainRouter"})," side, the handler is reliable.\nTimeouts are triggered when peers do not respond and the ",(0,t.jsx)(n.code,{children:"ChainRouter"})," will\nstill notify the handler of failure cases. The timeout manager within\n",(0,t.jsx)(n.code,{children:"ChainRouter"})," is also adaptive. If the network is experiencing long latencies,\ntimeouts will then be adjusted as well."]}),"\n",(0,t.jsx)(n.h2,{id:"handler",children:"Handler"}),"\n",(0,t.jsxs)(n.p,{children:["The main function of ",(0,t.jsxs)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/networking/handler/handler.go",children:["the\n",(0,t.jsx)(n.code,{children:"Handler"})]}),"\nis to pass messages from the network to the consensus engine. It receives these\nmessages from the ",(0,t.jsx)(n.code,{children:"ChainRouter"}),". It passes messages by pushing them onto a sync\nor Async queue (depends on message type). Messages are then popped from the\nqueue, parsed, and routed to the correct function in consensus engine. This can\nbe one of the following."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"State sync message (sync queue)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Bootstrapping message (sync queue)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Consensus message (sync queue)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"App message (Async queue)"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"sender",children:"Sender"}),"\n",(0,t.jsxs)(n.p,{children:["The main role of ",(0,t.jsxs)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/networking/sender/sender.go",children:["the\n",(0,t.jsx)(n.code,{children:"sender"})]}),"\nis to build and send outbound messages. It is actually a very thin wrapper\naround the normal networking code. The main difference here is that sender\nregisters timeouts and tells the router to expect a response message. The timer\nstarts on the sender side. If there is no response, sender will send a failed\nresponse to the router. If a node is repeatedly unresponsive, that node will get\nbenched and the sender will immediately start marking those messages as failed.\nIf a sufficient amount of network deems the node benched, it might not get\nrewards (as a validator)."]}),"\n",(0,t.jsx)(n.h2,{id:"consensus-engine",children:"Consensus Engine"}),"\n",(0,t.jsxs)(n.p,{children:["Consensus is defined as getting a group of distributed systems to agree on an\noutcome. In the case of the Lux network, consensus is achieved when\nvalidators are in agreement with the state of the blockchain. The novel\nconsensus algorithm is documented in the ",(0,t.jsx)(n.a,{href:"https://assets.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Lux%20Consensus%20Whitepaper.pdf",children:"white\npaper"}),".\nThere are two main consensus algorithms: Lux and\n",(0,t.jsx)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/consensus/snowman/consensus.go",children:"Snowman"}),".\nThe engine is responsible for adding proposing a new block to consensus,\nrepeatedly polling the network for decisions (accept/reject), and communicating\nthat decision to the ",(0,t.jsx)(n.code,{children:"Sender"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"blockchain-creation",children:"Blockchain Creation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/chains/manager.go",children:["The\n",(0,t.jsx)(n.code,{children:"Manager"})]}),"\nis what kick-starts everything in regards to blockchain creation, starting with\nthe P-Chain. Once the P-Chain finishes bootstrapping, it will kickstart C-Chain\nand X-Chain and any other chains. The ",(0,t.jsx)(n.code,{children:"Manager"}),"\u2019s job is not done yet, if a\ncreate-chain transaction is seen by a validator, a whole new process to create a\nchain will be started by the ",(0,t.jsx)(n.code,{children:"Manager"}),". This can happen dynamically, long after\nthe 3 chains in the Primary Network have been created and bootstrapped."]})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},51361:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/blockchain-flow-e442f82b0822725d41a71ca8252be2e2.png"},43540:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var t=s(48318);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);
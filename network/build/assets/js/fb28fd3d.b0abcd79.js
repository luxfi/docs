"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[5938],{34529:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>c,toc:()=>h});var o=n(49214),i=n(43540),r=n(28237),s=n(13262);const l={tags:["Build","Virtual Machines"],description:"In this guide, we'll define the precompile by implementing the `HelloWorld` interface.",sidebar_label:"Defining Your Precompile",pagination_label:"Defining Your Precompile",sidebar_position:3},a="Defining Your Precompile",c={id:"build/vm/evm/defining-precompile",title:"Defining Your Precompile",description:"In this guide, we'll define the precompile by implementing the `HelloWorld` interface.",source:"@site/docs/build/vm/evm/defining-precompile.md",sourceDirName:"build/vm/evm",slug:"/build/vm/evm/defining-precompile",permalink:"/docs/build/vm/evm/defining-precompile",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/build/vm/evm/defining-precompile.md",tags:[{label:"Build",permalink:"/docs/tags/build"},{label:"Virtual Machines",permalink:"/docs/tags/virtual-machines"}],version:"current",sidebarPosition:3,frontMatter:{tags:["Build","Virtual Machines"],description:"In this guide, we'll define the precompile by implementing the `HelloWorld` interface.",sidebar_label:"Defining Your Precompile",pagination_label:"Defining Your Precompile",sidebar_position:3},sidebar:"build-vm",previous:{title:"Generating Your Precompile",permalink:"/docs/build/vm/evm/generate-precompile"},next:{title:"Writing Test Cases",permalink:"/docs/build/vm/evm/defining-tests"}},d={},h=[{value:"Setting Config Key",id:"setting-config-key",level:2},{value:"Setting Contract Address",id:"setting-contract-address",level:2},{value:"Adding Custom Code",id:"adding-custom-code",level:2},{value:"Module File",id:"module-file",level:3},{value:"Configure()",id:"configure",level:4},{value:"Config File",id:"config-file",level:3},{value:"Verify()",id:"verify",level:4},{value:"Equal()",id:"equal",level:4},{value:"Modify Configure()",id:"modify-configure",level:3},{value:"Contract File",id:"contract-file",level:3},{value:"Packers and Unpackers",id:"packers-and-unpackers",level:4},{value:"Modify sayHello()",id:"modify-sayhello",level:4},{value:"Modify setGreeting()",id:"modify-setgreeting",level:4},{value:"Setting Gas Costs",id:"setting-gas-costs",level:2},{value:"Registering Your Precompile",id:"registering-your-precompile",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"defining-your-precompile",children:"Defining Your Precompile"}),"\n","\n",(0,o.jsx)(t.p,{children:"Now that we have autogenerated the template code required for our precompile, let's actually write the logic for the precompile itself."}),"\n",(0,o.jsx)(t.h2,{id:"setting-config-key",children:"Setting Config Key"}),"\n",(0,o.jsxs)(t.p,{children:["Let's jump to ",(0,o.jsx)(t.code,{children:"helloworld/module.go"})," file first. This file contains the module definition for our\nprecompile. You can see the ",(0,o.jsx)(t.code,{children:"ConfigKey"})," is set to some default value of ",(0,o.jsx)(t.code,{children:"helloWorldConfig"}),".\nThis key should be unique to the precompile.\nThis config key determines which JSON key to use when reading the precompile's config from the\nJSON upgrade/genesis file. In this case, the config key is ",(0,o.jsx)(t.code,{children:"helloWorldConfig"})," and the JSON config\nshould look like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'{\n  "helloWorldConfig": {\n    "blockTimestamp": 0\n\t\t...\n  }\n}\n'})}),"\n",(0,o.jsx)(t.h2,{id:"setting-contract-address",children:"Setting Contract Address"}),"\n",(0,o.jsxs)(t.p,{children:["In the ",(0,o.jsx)(t.code,{children:"helloworld/module.go"})," you can see the ",(0,o.jsx)(t.code,{children:"ContractAddress"})," is set to some default value.\nThis should be changed to a suitable address for your precompile.\nThe address should be unique to the precompile. There is a registry of precompile addresses\nunder ",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/precompile/registry/registry.go",children:(0,o.jsx)(t.code,{children:"precompile/registry/registry.go"})}),".\nA list of addresses is specified in the comments under this file.\nModify the default value to be the next user available stateful precompile address. For forks of\nSubnet-EVM or Precompile-EVM, users should start at ",(0,o.jsx)(t.code,{children:"0x0300000000000000000000000000000000000000"})," to ensure\nthat their own modifications do not conflict with stateful precompiles that may be added to\nSubnet-EVM in the future. You should pick an address that is not already taken."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// This list is kept just for reference. The actual addresses defined in respective packages of precompiles.\n// Note: it is important that none of these addresses conflict with each other or any other precompiles\n// in core/vm/contracts.go.\n// The first stateful precompiles were added in coreth to support nativeAssetCall and nativeAssetBalance. New stateful precompiles\n// originating in coreth will continue at this prefix, so we reserve this range in subnet-evm so that they can be migrated into\n// subnet-evm without issue.\n// These start at the address: 0x0100000000000000000000000000000000000000 and will increment by 1.\n// Optional precompiles implemented in subnet-evm start at 0x0200000000000000000000000000000000000000 and will increment by 1\n// from here to reduce the risk of conflicts.\n// For forks of subnet-evm, users should start at 0x0300000000000000000000000000000000000000 to ensure\n// that their own modifications do not conflict with stateful precompiles that may be added to subnet-evm\n// in the future.\n// ContractDeployerAllowListAddress = common.HexToAddress("0x0200000000000000000000000000000000000000")\n// ContractNativeMinterAddress      = common.HexToAddress("0x0200000000000000000000000000000000000001")\n// TxAllowListAddress               = common.HexToAddress("0x0200000000000000000000000000000000000002")\n// FeeManagerAddress                = common.HexToAddress("0x0200000000000000000000000000000000000003")\n// RewardManagerAddress             = common.HexToAddress("0x0200000000000000000000000000000000000004")\n// HelloWorldAddress                = common.HexToAddress("0x0300000000000000000000000000000000000000")\n// ADD YOUR PRECOMPILE HERE\n// {YourPrecompile}Address          = common.HexToAddress("0x03000000000000000000000000000000000000??")\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Don't forget to update the actual variable ",(0,o.jsx)(t.code,{children:"ContractAddress"})," in ",(0,o.jsx)(t.code,{children:"module.go"})," to the address you chose.\nIt should look like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// ContractAddress is the defined address of the precompile contract.\n// This should be unique across all precompile contracts.\n// See params/precompile_modules.go for registered precompile contracts and more information.\nvar ContractAddress = common.HexToAddress("0x0300000000000000000000000000000000000000")\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Now when Subnet-EVM sees the ",(0,o.jsx)(t.code,{children:"helloworld.ContractAddress"})," as input when executing\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/core/vm/evm.go#L284",children:(0,o.jsx)(t.code,{children:"CALL"})}),",\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/core/vm/evm.go#L355",children:(0,o.jsx)(t.code,{children:"CALLCODE"})}),",\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/core/vm/evm.go#L396",children:(0,o.jsx)(t.code,{children:"DELEGATECALL"})}),",\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/core/vm/evm.go#L445",children:(0,o.jsx)(t.code,{children:"STATICCALL"})}),",\nit can run the precompile if the precompile is enabled."]}),"\n",(0,o.jsx)(t.h2,{id:"adding-custom-code",children:"Adding Custom Code"}),"\n",(0,o.jsxs)(t.p,{children:["Search (",(0,o.jsx)(t.code,{children:"CTRL F"}),") throughout the file with ",(0,o.jsx)(t.code,{children:"CUSTOM CODE STARTS HERE"})," to find the areas in the\nprecompile package that you need to modify. You should start with the reference imports code block."]}),"\n",(0,o.jsx)(t.h3,{id:"module-file",children:"Module File"}),"\n",(0,o.jsxs)(t.p,{children:["The module file contains fundamental information about the precompile. This includes the key for the\nprecompile, the address of the precompile, and a configurator. This file is located at\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/precompile/contracts/helloworld/module.go",children:(0,o.jsx)(t.code,{children:"./precompile/helloworld/module.go"})}),"\nfor Subnet-EVM and\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/precompile-evm/blob/hello-world-example/helloworld/module.go",children:"./helloworld/module.go"}),"\nfor Precompile-EVM."]}),"\n",(0,o.jsxs)(t.p,{children:["This file defines the module for the precompile. The module is used to register the precompile to the\nprecompile registry. The precompile registry is used to read configs and enable the precompile.\nRegistration is done in the ",(0,o.jsx)(t.code,{children:"init()"})," function of the module file. ",(0,o.jsx)(t.code,{children:"MakeConfig()"})," is used to create a\nnew instance for the precompile config. This will be used in custom Unmarshal/Marshal logic.\nYou don't need to override these functions."]}),"\n",(0,o.jsx)(t.h4,{id:"configure",children:"Configure()"}),"\n",(0,o.jsxs)(t.p,{children:["Module file contains a ",(0,o.jsx)(t.code,{children:"configurator"})," which implements the ",(0,o.jsx)(t.code,{children:"contract.Configurator"})," interface. This interface\nincludes a ",(0,o.jsx)(t.code,{children:"Configure()"})," function used to configure the precompile and set the initial\nstate of the precompile. This function is called when the precompile is enabled. This is typically used\nto read from a given config in upgrade/genesis JSON and sets the initial state of the\nprecompile accordingly. This function also calls ",(0,o.jsx)(t.code,{children:"AllowListConfig.Configure()"})," to invoke AllowList\nconfiguration as the last step. You should keep it as it is if you want to use AllowList.\nYou can modify this function for your custom logic. You can circle back to this function later\nafter you have finalized the implementation of the precompile config."]}),"\n",(0,o.jsx)(t.h3,{id:"config-file",children:"Config File"}),"\n",(0,o.jsxs)(t.p,{children:["The config file contains the config for the precompile. This file is located at\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/precompile/contracts/helloworld/config.go",children:(0,o.jsx)(t.code,{children:"./precompile/helloworld/config.go"})}),"\nfor Subnet-EVM and\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/precompile-evm/blob/hello-world-example/helloworld/config.go",children:"./helloworld/config.go"}),"\nfor Precompile-EVM.\nThis file contains the ",(0,o.jsx)(t.code,{children:"Config"})," struct, which implements ",(0,o.jsx)(t.code,{children:"precompileconfig.Config"})," interface.\nIt has some embedded structs like ",(0,o.jsx)(t.code,{children:"precompileconfig.Upgrade"}),". ",(0,o.jsx)(t.code,{children:"Upgrade"})," is used to enable\nupgrades for the precompile. It contains the ",(0,o.jsx)(t.code,{children:"BlockTimestamp"})," and ",(0,o.jsx)(t.code,{children:"Disable"})," to enable/disable\nupgrades. ",(0,o.jsx)(t.code,{children:"BlockTimestamp"})," is the timestamp of the block when the upgrade will be activated.\n",(0,o.jsx)(t.code,{children:"Disable"})," is used to disable the upgrade. If you use ",(0,o.jsx)(t.code,{children:"AllowList"})," for the precompile, there is also\n",(0,o.jsx)(t.code,{children:"allowlist.AllowListConfig"})," embedded in the ",(0,o.jsx)(t.code,{children:"Config"})," struct. ",(0,o.jsx)(t.code,{children:"AllowListConfig"})," is used to specify initial\nroles for specified addresses. If you have any custom fields in your precompile config, you can add them\nhere. These custom fields will be read from upgrade/genesis JSON and set in the precompile config."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"// Config implements the precompileconfig.Config interface and\n// adds specific configuration for HelloWorld.\ntype Config struct {\n\tallowlist.AllowListConfig\n\tprecompileconfig.Upgrade\n}\n"})}),"\n",(0,o.jsx)(t.h4,{id:"verify",children:"Verify()"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"Verify()"})," is called on startup and an error is treated as fatal. Generated code contains a call\nto ",(0,o.jsx)(t.code,{children:"AllowListConfig.Verify()"})," to verify the ",(0,o.jsx)(t.code,{children:"AllowListConfig"}),". You can leave that as is and start\nadding your own custom verify code after that."]}),"\n",(0,o.jsxs)(t.p,{children:["We can leave this function as is right now because there is no invalid custom configuration for the ",(0,o.jsx)(t.code,{children:"Config"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"// Verify tries to verify Config and returns an error accordingly.\nfunc (c *Config) Verify() error {\n\t// Verify AllowList first\n\tif err := c.AllowListConfig.Verify(); err != nil {\n\t\treturn err\n\t}\n\n\t// CUSTOM CODE STARTS HERE\n\t// Add your own custom verify code for Config here\n\t// and return an error accordingly\n\treturn nil\n}\n"})}),"\n",(0,o.jsx)(t.h4,{id:"equal",children:"Equal()"}),"\n",(0,o.jsxs)(t.p,{children:["Next, we see is ",(0,o.jsx)(t.code,{children:"Equal()"}),". This function determines if two precompile configs are equal. This is used\nto determine if the precompile needs to be upgraded. There is some default code that is generated for\nchecking ",(0,o.jsx)(t.code,{children:"Upgrade"})," and ",(0,o.jsx)(t.code,{children:"AllowListConfig"})," equality."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"// Equal returns true if [s] is a [*Config] and it has been configured identical to [c].\nfunc (c *Config) Equal(s precompileconfig.Config) bool {\n\t// typecast before comparison\n\tother, ok := (s).(*Config)\n\tif !ok {\n\t\treturn false\n\t}\n\t// CUSTOM CODE STARTS HERE\n\t// modify this boolean accordingly with your custom Config, to check if [other] and the current [c] are equal\n\t// if Config contains only Upgrade  and AllowListConfig  you can skip modifying it.\n\tequals := c.Upgrade.Equal(&other.Upgrade) && c.AllowListConfig.Equal(&other.AllowListConfig)\n\treturn equals\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We can leave this function as is since we check ",(0,o.jsx)(t.code,{children:"Upgrade"})," and ",(0,o.jsx)(t.code,{children:"AllowListConfig"})," for equality which are\nthe only fields that ",(0,o.jsx)(t.code,{children:"Config"})," struct has."]}),"\n",(0,o.jsx)(t.h3,{id:"modify-configure",children:"Modify Configure()"}),"\n",(0,o.jsxs)(t.p,{children:["We can now circle back to ",(0,o.jsx)(t.code,{children:"Configure()"})," in ",(0,o.jsx)(t.code,{children:"module.go"})," as we finished implementing ",(0,o.jsx)(t.code,{children:"Config"})," struct.\nThis function configures the ",(0,o.jsx)(t.code,{children:"state"})," with the\ninitial configuration at",(0,o.jsx)(t.code,{children:"blockTimestamp"})," when the precompile is enabled.\nIn the HelloWorld example, we want to set up a default\nkey-value mapping in the state where the key is ",(0,o.jsx)(t.code,{children:"storageKey"})," and the value is ",(0,o.jsx)(t.code,{children:"Hello World!"}),". The\n",(0,o.jsx)(t.code,{children:"StateDB"})," allows us to store a key-value mapping of 32-byte hashes. The below code snippet can be\ncopied and pasted to overwrite the default ",(0,o.jsx)(t.code,{children:"Configure()"})," code."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'const defaultGreeting = "Hello World!"\n\n// Configure configures [state] with the given [cfg] precompileconfig.\n// This function is called by the EVM once per precompile contract activation.\n// You can use this function to set up your precompile contract\'s initial state,\n// by using the [cfg] config and [state] stateDB.\nfunc (*configurator) Configure(chainConfig contract.ChainConfig, cfg precompileconfig.Config, state contract.StateDB, _ contract.BlockContext) error {\n\tconfig, ok := cfg.(*Config)\n\tif !ok {\n\t\treturn fmt.Errorf("incorrect config %T: %v", config, config)\n\t}\n\t// CUSTOM CODE STARTS HERE\n\n\t// This will be called in the first block where HelloWorld stateful precompile is enabled.\n\t// 1) If BlockTimestamp is nil, this will not be called\n\t// 2) If BlockTimestamp is 0, this will be called while setting up the genesis block\n\t// 3) If BlockTimestamp is 1000, this will be called while processing the first block\n\t// whose timestamp is >= 1000\n\t//\n\t// Set the initial value under [common.BytesToHash([]byte("storageKey")] to "Hello World!"\n\tStoreGreeting(state, defaultGreeting)\n\t// AllowList is activated for this precompile. Configuring allowlist addresses here.\n\treturn config.AllowListConfig.Configure(state, ContractAddress)\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"contract-file",children:"Contract File"}),"\n",(0,o.jsxs)(t.p,{children:["The contract file contains the functions of the precompile contract that will be called by the EVM. The\nfile is located at ",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/precompile/contracts/helloworld/contract.go",children:(0,o.jsx)(t.code,{children:"./precompile/helloworld/contract.go"})}),"\nfor Subnet-EVM and\n",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/precompile-evm/blob/hello-world-example/helloworld/contract.go",children:"./helloworld/contract.go"}),"\nfor Precompile-EVM.\nSince we use ",(0,o.jsx)(t.code,{children:"IAllowList"})," interface there will be auto-generated code for ",(0,o.jsx)(t.code,{children:"AllowList"}),"\nfunctions like below:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"// GetHelloWorldAllowListStatus returns the role of [address] for the HelloWorld list.\nfunc GetHelloWorldAllowListStatus(stateDB contract.StateDB, address common.Address) allowlist.Role {\n\treturn allowlist.GetAllowListStatus(stateDB, ContractAddress, address)\n}\n\n// SetHelloWorldAllowListStatus sets the permissions of [address] to [role] for the\n// HelloWorld list. Assumes [role] has already been verified as valid.\n// This stores the [role] in the contract storage with address [ContractAddress]\n// and [address] hash. It means that any reusage of the [address] key for different value\n// conflicts with the same slot [role] is stored.\n// Precompile implementations must use a different key than [address] for their storage.\nfunc SetHelloWorldAllowListStatus(stateDB contract.StateDB, address common.Address, role allowlist.Role) {\n\tallowlist.SetAllowListRole(stateDB, ContractAddress, address, role)\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"These will be helpful to use AllowList precompile helper in our functions."}),"\n",(0,o.jsx)(t.h4,{id:"packers-and-unpackers",children:"Packers and Unpackers"}),"\n",(0,o.jsxs)(t.p,{children:["There are also auto-generated Packers and Unpackers for the ABI. These will be used in ",(0,o.jsx)(t.code,{children:"sayHello"})," and\n",(0,o.jsx)(t.code,{children:"setGreeting"})," functions to comfort the ABI.\nThese functions are auto-generated\nand will be used in necessary places accordingly.\nYou don't need to worry about how to deal with them, but it's good to know what they are."]}),"\n",(0,o.jsxs)(t.p,{children:["Each input to a precompile contract function has it's own ",(0,o.jsx)(t.code,{children:"Unpacker"})," function as follows:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// UnpackSetGreetingInput attempts to unpack [input] into the string type argument\n// assumes that [input] does not include selector (omits first 4 func signature bytes)\nfunc UnpackSetGreetingInput(input []byte) (string, error) {\n\tres, err := HelloWorldABI.UnpackInput("setGreeting", input)\n\tif err != nil {\n\t\treturn "", err\n\t}\n\tunpacked := *abi.ConvertType(res[0], new(string)).(*string)\n\treturn unpacked, nil\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The ABI is a binary format and the input to the precompile contract function is a\nbyte array. The ",(0,o.jsx)(t.code,{children:"Unpacker"})," function converts this input to a more easy-to-use format so that we can\nuse it in our function."]}),"\n",(0,o.jsxs)(t.p,{children:["Similarly, there is a ",(0,o.jsx)(t.code,{children:"Packer"})," function for each output of a precompile contract function as follows:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// PackSayHelloOutput attempts to pack given result of type string\n// to conform the ABI outputs.\nfunc PackSayHelloOutput(result string) ([]byte, error) {\n\treturn HelloWorldABI.PackOutput("sayHello", result)\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"This function converts the output of the function to a byte array that conforms to the ABI and can be\nreturned to the EVM as a result."}),"\n",(0,o.jsx)(t.h4,{id:"modify-sayhello",children:"Modify sayHello()"}),"\n",(0,o.jsxs)(t.p,{children:["The next place to modify is in our ",(0,o.jsx)(t.code,{children:"sayHello()"})," function. In a previous step, we created the ",(0,o.jsx)(t.code,{children:"IHelloWorld.sol"}),"\ninterface with two functions ",(0,o.jsx)(t.code,{children:"sayHello()"})," and ",(0,o.jsx)(t.code,{children:"setGreeting()"}),". We finally get to implement them here.\nIf any contract calls these functions from the interface, the below function gets executed. This function\nis a simple getter function. In ",(0,o.jsx)(t.code,{children:"Configure()"})," we set up a mapping with the key as ",(0,o.jsx)(t.code,{children:"storageKey"})," and\nthe value as ",(0,o.jsx)(t.code,{children:"Hello World!"})," In this function, we will be returning whatever value is at ",(0,o.jsx)(t.code,{children:"storageKey"}),".\nThe below code snippet can be copied and pasted to overwrite the default ",(0,o.jsx)(t.code,{children:"setGreeting"})," code."]}),"\n",(0,o.jsxs)(t.p,{children:["First, we add a helper function to get the greeting value from the stateDB, this will be helpful\nwhen we test our contract. We will use the ",(0,o.jsx)(t.code,{children:"storageKeyHash"})," to store the value in the Contract's\nreserved storage in the stateDB."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'var (\n  // storageKeyHash is the hash of the storage key "storageKey" in the contract storage.\n\t// This is used to store the value of the greeting in the contract storage.\n\t// It is important to use a unique key here to avoid conflicts with other storage keys\n\t// like addresses, AllowList, etc.\n\tstorageKeyHash = common.BytesToHash([]byte("storageKey"))\n)\n// GetGreeting returns the value of the storage key "storageKey" in the contract storage,\n// with leading zeroes trimmed.\n// This function is mostly used for tests.\nfunc GetGreeting(stateDB contract.StateDB) string {\n\t// Get the value set at recipient\n\tvalue := stateDB.GetState(ContractAddress, storageKeyHash)\n\treturn string(common.TrimLeftZeroes(value.Bytes()))\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Now we can modify the ",(0,o.jsx)(t.code,{children:"sayHello"})," function to return the stored value."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"func sayHello(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {\n\tif remainingGas, err = contract.DeductGas(suppliedGas, SayHelloGasCost); err != nil {\n\t\treturn nil, 0, err\n\t}\n\t// CUSTOM CODE STARTS HERE\n\n\t// Get the current state\n\tcurrentState := accessibleState.GetStateDB()\n\t// Get the value set at recipient\n\tvalue := GetGreeting(currentState)\n\tpackedOutput, err := PackSayHelloOutput(value)\n\tif err != nil {\n\t\treturn nil, remainingGas, err\n\t}\n\n\t// Return the packed output and the remaining gas\n\treturn packedOutput, remainingGas, nil\n}\n"})}),"\n",(0,o.jsx)(t.h4,{id:"modify-setgreeting",children:"Modify setGreeting()"}),"\n",(0,o.jsxs)(t.p,{children:["We can also modify our ",(0,o.jsx)(t.code,{children:"setGreeting()"})," function. This is a simple setter function. It takes in ",(0,o.jsx)(t.code,{children:"input"}),"\nand we will set that as the value in the state mapping with the key as ",(0,o.jsx)(t.code,{children:"storageKey"}),". It also checks\nif the VM running the precompile is in read-only mode. If it is, it returns an error."]}),"\n",(0,o.jsxs)(t.p,{children:["There is also a generated ",(0,o.jsx)(t.code,{children:"AllowList"})," code in that function. This generated code checks if the caller\naddress is eligible to perform this state-changing operation. If not, it returns an error."]}),"\n",(0,o.jsx)(t.p,{children:"Let's add the helper function to set the greeting value in the stateDB, this will be helpful\nwhen we test our contract."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// StoreGreeting sets the value of the storage key "storageKey" in the contract storage.\nfunc StoreGreeting(stateDB contract.StateDB, input string) {\n\tinputPadded := common.LeftPadBytes([]byte(input), common.HashLength)\n\tinputHash := common.BytesToHash(inputPadded)\n\n\tstateDB.SetState(ContractAddress, storageKeyHash, inputHash)\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The below code snippet can be copied and pasted to overwrite the default ",(0,o.jsx)(t.code,{children:"setGreeting()"})," code."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'func setGreeting(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {\n\tif remainingGas, err = contract.DeductGas(suppliedGas, SetGreetingGasCost); err != nil {\n\t\treturn nil, 0, err\n\t}\n\tif readOnly {\n\t\treturn nil, remainingGas, vmerrs.ErrWriteProtection\n\t}\n\t// attempts to unpack [input] into the arguments to the SetGreetingInput.\n\t// Assumes that [input] does not include selector\n\t// You can use unpacked [inputStruct] variable in your code\n\tinputStruct, err := UnpackSetGreetingInput(input)\n\tif err != nil {\n\t\treturn nil, remainingGas, err\n\t}\n\n\t// Allow list is enabled and SetGreeting is a state-changer function.\n\t// This part of the code restricts the function to be called only by enabled/admin addresses in the allow list.\n\t// You can modify/delete this code if you don\'t want this function to be restricted by the allow list.\n\tstateDB := accessibleState.GetStateDB()\n\t// Verify that the caller is in the allow list and therefore has the right to call this function.\n\tcallerStatus := allowlist.GetAllowListStatus(stateDB, ContractAddress, caller)\n\tif !callerStatus.IsEnabled() {\n\t\treturn nil, remainingGas, fmt.Errorf("%w: %s", ErrCannotSetGreeting, caller)\n\t}\n\t// allow list code ends here.\n\n\t// CUSTOM CODE STARTS HERE\n\t// Check if the input string is longer than HashLength\n\tif len(inputStruct) > common.HashLength {\n\t\treturn nil, 0, ErrInputExceedsLimit\n\t}\n\n\t// setGreeting is the execution function\n\t// "SetGreeting(name string)" and sets the storageKey\n\t// in the string returned by hello world\n\tStoreGreeting(stateDB, inputStruct)\n\n\t// This function does not return an output, leave this one as is\n\tpackedOutput := []byte{}\n\n\t// Return the packed output and the remaining gas\n\treturn packedOutput, remainingGas, nil\n}\n'})}),"\n",(0,o.jsx)(t.h2,{id:"setting-gas-costs",children:"Setting Gas Costs"}),"\n",(0,o.jsxs)(t.p,{children:["Setting gas costs for functions is very important and should be done carefully.\nIf the gas costs are set too low,\nthen functions can be abused and can cause DoS attacks.\nIf the gas costs are set too high, then the contract will be too expensive\nto run.\nSubnet-EVM has some predefined gas costs for write and read operations\nin ",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/precompile/contract/utils.go#L19-L20",children:(0,o.jsx)(t.code,{children:"precompile/contract/utils.go"})}),".\nIn order to provide a baseline for gas costs, we have set the following gas costs."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"// Gas costs for stateful precompiles\nconst (\n\tWriteGasCostPerSlot = 20_000\n\tReadGasCostPerSlot  = 5_000\n)\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"WriteGasCostPerSlot"})," is the cost of one write such as modifying a state storage slot."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"ReadGasCostPerSlot"})," is the cost of reading a state storage slot."]}),"\n",(0,o.jsxs)(t.p,{children:["This should be in your gas cost estimations based on how many times the precompile function does a\nread or a write. For example, if the precompile modifies the state slot of its precompile address\ntwice then the gas cost for that function would be ",(0,o.jsx)(t.code,{children:"40_000"}),". However, if the precompile does additional\noperations and requires more computational power, then you should increase the gas costs accordingly."]}),"\n",(0,o.jsxs)(t.p,{children:["On top of these gas costs, we also have to account for the gas costs of AllowList gas costs. These\nare the gas costs of reading and writing permissions for addresses in AllowList. These are defined\nunder Subnet-EVM's ",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/precompile/allowlist/allowlist.go#L28-L29",children:(0,o.jsx)(t.code,{children:"precompile/allowlist/allowlist.go"})}),".\nBy default, these are added to the default gas costs of the state-change functions (SetGreeting)\nof the precompile. Meaning that these functions will cost an additional ",(0,o.jsx)(t.code,{children:"ReadAllowListGasCost"})," in order\nto read permissions from the storage. If you don't plan to read permissions from the storage then\nyou can omit these."]}),"\n",(0,o.jsxs)(t.p,{children:["Now going back to our ",(0,o.jsx)(t.code,{children:"/helloworld/contract.go"}),", we can modify our precompile function gas costs.\nPlease search (",(0,o.jsx)(t.code,{children:"CTRL F"}),") ",(0,o.jsx)(t.code,{children:"SET A GAS COST HERE"})," to locate the default gas cost code."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"SayHelloGasCost    uint64 = 0                                  // SET A GAS COST HERE\nSetGreetingGasCost uint64 = 0 + allowlist.ReadAllowListGasCost // SET A GAS COST HERE\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We get and set our greeting with ",(0,o.jsx)(t.code,{children:"sayHello()"})," and ",(0,o.jsx)(t.code,{children:"setGreeting()"})," in one slot\nrespectively so we can define the gas costs as follows. We also read permissions from the\nAllowList in ",(0,o.jsx)(t.code,{children:"setGreeting()"})," so we keep ",(0,o.jsx)(t.code,{children:"allowlist.ReadAllowListGasCost"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:"SayHelloGasCost    uint64 = contract.ReadGasCostPerSlot\nSetGreetingGasCost uint64 = contract.WriteGasCostPerSlot + allowlist.ReadAllowListGasCost\n"})}),"\n",(0,o.jsx)(t.h2,{id:"registering-your-precompile",children:"Registering Your Precompile"}),"\n",(0,o.jsxs)(t.p,{children:["We should register our precompile package to the Subnet-EVM to be discovered by other packages.\nOur ",(0,o.jsx)(t.code,{children:"Module"})," file contains an ",(0,o.jsx)(t.code,{children:"init()"})," function that registers our precompile.\n",(0,o.jsx)(t.code,{children:"init()"})," is called when the package is imported.\nWe should register our precompile in a common package so\nthat it can be imported by other packages."]}),"\n",(0,o.jsxs)(r.A,{groupId:"evm-tabs",children:[(0,o.jsxs)(s.A,{value:"subnet-evm-tab",label:"Subnet-EVM",default:!0,children:[(0,o.jsxs)(t.p,{children:["For Subnet-EVM we have a precompile registry under ",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/precompile/registry/registry.go",children:(0,o.jsx)(t.code,{children:"/precompile/registry/registry.go"})}),".\nThis registry force-imports precompiles from other packages, for example:"]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// Force imports of each precompile to ensure each precompile\'s init function runs and registers itself\n// with the registry.\nimport (\n\t_ "github.com/luxfi/subnet-evm/precompile/contracts/deployerallowlist"\n\n\t_ "github.com/luxfi/subnet-evm/precompile/contracts/nativeminter"\n\n\t_ "github.com/luxfi/subnet-evm/precompile/contracts/txallowlist"\n\n\t_ "github.com/luxfi/subnet-evm/precompile/contracts/feemanager"\n\n\t_ "github.com/luxfi/subnet-evm/precompile/contracts/rewardmanager"\n\n\t_ "github.com/luxfi/subnet-evm/precompile/contracts/helloworld"\n\t// ADD YOUR PRECOMPILE HERE\n\t// _ "github.com/luxfi/subnet-evm/precompile/contracts/yourprecompile"\n)\n'})}),(0,o.jsxs)(t.p,{children:["The registry itself also force-imported by the ",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/subnet-evm/blob/helloworld-official-tutorial-v2/plugin/evm/vm.go#L50",children:"`/plugin/evm/vm.go"}),".\nThis ensures that the registry is imported and the precompiles are registered."]})]}),(0,o.jsxs)(s.A,{value:"precompile-evm-tab",label:"Precompile-EVM",children:[(0,o.jsxs)(t.p,{children:["For Precompile-EVM there is a ",(0,o.jsx)(t.a,{href:"https://github.com/luxfi/precompile-evm/blob/hello-world-example/plugin/main.go",children:(0,o.jsx)(t.code,{children:"plugin/main.go"})}),"\nfile in Precompile-EVM that orchestrates this precompile registration."]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// (c) 2019-2023, Lux Partners, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\npackage main\n\nimport (\n\t"fmt"\n\n\t"github.com/luxfi/luxd/version"\n\t"github.com/luxfi/subnet-evm/plugin/evm"\n\t"github.com/luxfi/subnet-evm/plugin/runner"\n\n\t// Each precompile generated by the precompilegen tool has a self-registering init function\n\t// that registers the precompile with the subnet-evm. Importing the precompile package here\n\t// will cause the precompile to be registered with the subnet-evm.\n\t_ "github.com/luxfi/precompile-evm/helloworld"\n\t// ADD YOUR PRECOMPILE HERE\n\t//_ "github.com/luxfi/precompile-evm/{yourprecompilepkg}"\n)\n'})})]})]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},13262:(e,t,n)=>{n.d(t,{A:()=>s});n(48318);var o=n(23372);const i={tabItem:"tabItem_QyJb"};var r=n(49214);function s(e){let{children:t,hidden:n,className:s}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,o.A)(i.tabItem,s),hidden:n,children:t})}},28237:(e,t,n)=>{n.d(t,{A:()=>j});var o=n(48318),i=n(23372),r=n(70604),s=n(66325),l=n(849),a=n(54313),c=n(77638),d=n(75590);function h(e){return o.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,o.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:o,default:i}}=e;return{value:t,label:n,attributes:o,default:i}}))}(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const i=(0,s.W6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,a.aZ)(r),(0,o.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(i.location.search);t.set(r,e),i.replace({...i.location,search:t.toString()})}),[r,i])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,r=u(e),[s,a]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const o=n.find((e=>e.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:t,tabValues:r}))),[c,h]=f({queryString:n,groupId:i}),[g,m]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,r]=(0,d.Dv)(n);return[i,(0,o.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:i}),b=(()=>{const e=c??g;return p({value:e,tabValues:r})?e:null})();(0,l.A)((()=>{b&&a(b)}),[b]);return{selectedValue:s,selectValue:(0,o.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);a(e),h(e),m(e)}),[h,m,r]),tabValues:r}}var m=n(16883);const b={tabList:"tabList_hAgJ",tabItem:"tabItem_inov"};var x=n(49214);function w(e){let{className:t,block:n,selectedValue:o,selectValue:s,tabValues:l}=e;const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.a_)(),d=e=>{const t=e.currentTarget,n=a.indexOf(t),i=l[n].value;i!==o&&(c(t),s(i))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=a.indexOf(e.currentTarget)+1;t=a[n]??a[0];break}case"ArrowLeft":{const n=a.indexOf(e.currentTarget)-1;t=a[n]??a[a.length-1];break}}t?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},t),children:l.map((e=>{let{value:t,label:n,attributes:r}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,ref:e=>a.push(e),onKeyDown:h,onClick:d,...r,className:(0,i.A)("tabs__item",b.tabItem,r?.className,{"tabs__item--active":o===t}),children:n??t},t)}))})}function y(e){let{lazy:t,children:n,selectedValue:i}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===i));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==i})))})}function v(e){const t=g(e);return(0,x.jsxs)("div",{className:(0,i.A)("tabs-container",b.tabList),children:[(0,x.jsx)(w,{...t,...e}),(0,x.jsx)(y,{...t,...e})]})}function j(e){const t=(0,m.A)();return(0,x.jsx)(v,{...e,children:h(e.children)},String(t))}},43540:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var o=n(48318);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);
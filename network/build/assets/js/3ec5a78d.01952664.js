"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[6711],{68428:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=t(49214),i=t(43540);const a={tags:["Tooling","LuxJS"],description:"LuxJS is a JavaScript Library for interfacing with the Lux platform. It is built using TypeScript and intended to support both browser and Node.js. The LuxJS library allows one to issue commands to the Lux node APIs.",pagination_label:"Multi Signature UTXOs with LuxJS",sidebar_label:"Multi Signature UTXOs",sidebar_position:7},r="Multi Signature UTXOs with LuxJS",o={id:"tooling/luxjs-guides/multisig-utxos-with-luxjs",title:"Multi Signature UTXOs with LuxJS",description:"LuxJS is a JavaScript Library for interfacing with the Lux platform. It is built using TypeScript and intended to support both browser and Node.js. The LuxJS library allows one to issue commands to the Lux node APIs.",source:"@site/docs/tooling/luxjs-guides/multisig-utxos-with-luxjs.md",sourceDirName:"tooling/luxjs-guides",slug:"/tooling/luxjs-guides/multisig-utxos-with-luxjs",permalink:"/docs/tooling/luxjs-guides/multisig-utxos-with-luxjs",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/tooling/luxjs-guides/multisig-utxos-with-luxjs.md",tags:[{label:"Tooling",permalink:"/docs/tags/tooling"},{label:"LuxJS",permalink:"/docs/tags/lux-js"}],version:"current",sidebarPosition:7,frontMatter:{tags:["Tooling","LuxJS"],description:"LuxJS is a JavaScript Library for interfacing with the Lux platform. It is built using TypeScript and intended to support both browser and Node.js. The LuxJS library allows one to issue commands to the Lux node APIs.",pagination_label:"Multi Signature UTXOs with LuxJS",sidebar_label:"Multi Signature UTXOs",sidebar_position:7},sidebar:"tooling",previous:{title:"Manage X-Chain Keys",permalink:"/docs/tooling/luxjs-guides/manage-x-chain-keys"},next:{title:"Glacier API",permalink:"/docs/tooling/glacier"}},d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Multi-Signature UTXOs",id:"multi-signature-utxos",level:2},{value:"Atomic Transactions",id:"atomic-transactions",level:2},{value:"UTXOs on C-Chain",id:"utxos-on-c-chain",level:2},{value:"Getting Hands-on Multi-Signature UTXOs",id:"getting-hands-on-multi-signature-utxos",level:2},{value:"Setting Up Project",id:"setting-up-project",level:2},{value:"Setting Up APIs and Keychains",id:"setting-up-apis-and-keychains",level:2},{value:"Importing Dependencies and Configurations",id:"importing-dependencies-and-configurations",level:3},{value:"Setup Lux APIs",id:"setup-lux-apis",level:3},{value:"Setup Keychains with Private Keys",id:"setup-keychains-with-private-keys",level:3},{value:"Setup Addresses and Chain IDs",id:"setup-addresses-and-chain-ids",level:3},{value:"Creating Utility Functions",id:"creating-utility-functions",level:2},{value:"Getting Dependencies",id:"getting-dependencies",level:3},{value:"Creating Transferable Output",id:"creating-transferable-output",level:3},{value:"Creating Transferable Input",id:"creating-transferable-input",level:3},{value:"Add Signature Indexes",id:"add-signature-indexes",level:3},{value:"Create EVM Input",id:"create-evm-input",level:3},{value:"Create EVM Output",id:"create-evm-output",level:3},{value:"Update Transfer Class",id:"update-transfer-class",level:3},{value:"Add UTXOs to Inputs",id:"add-utxos-to-inputs",level:3},{value:"Export Utility Functions",id:"export-utility-functions",level:3},{value:"Create Inputs and Outputs",id:"create-inputs-and-outputs",level:2},{value:"Importing Dependencies",id:"importing-dependencies",level:3},{value:"Exporting Functions",id:"exporting-functions",level:3},{value:"Examples",id:"examples",level:2},{value:"Multi-Signature Base TX on X-Chain",id:"multi-signature-base-tx-on-x-chain",level:2},{value:"Import Dependencies",id:"import-dependencies",level:3},{value:"Send BaseTx",id:"send-basetx",level:3},{value:"Export Multi-Sig UTXO From X to P-Chain",id:"export-multi-sig-utxo-from-x-to-p-chain",level:2},{value:"Import Dependencies",id:"import-dependencies-1",level:3},{value:"Send Export Transaction",id:"send-export-transaction",level:3},{value:"Import Multi-Sig UTXO From X to P-Chain",id:"import-multi-sig-utxo-from-x-to-p-chain",level:2},{value:"Import Dependencies",id:"import-dependencies-2",level:3},{value:"Send Import Transaction",id:"send-import-transaction",level:3},{value:"Import Multi-Sig UTXO From X to C-Chain",id:"import-multi-sig-utxo-from-x-to-c-chain",level:2},{value:"Add Delegator Transaction",id:"add-delegator-transaction",level:2},{value:"Import Dependencies",id:"import-dependencies-3",level:3},{value:"Sending AddDelegator Transaction",id:"sending-adddelegator-transaction",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"multi-signature-utxos-with-luxjs",children:"Multi Signature UTXOs with LuxJS"}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"An account on a chain that follows the UTXO model doesn't have a parameter like\nbalance. All it has is a bunch of outputs that are resulted from previous\ntransactions. Each output has some amount of asset associated with them. These\noutputs can have 1 or multiple owners. The owners are basically the account\naddresses that can consume this output."}),"\n",(0,s.jsx)(n.p,{children:"The outputs are the result of a transaction that can be spent by the owner of\nthat output. For example, an account has 3 outputs that it can spend, and hence\nare currently unspent. That is why we call them Unspent Transaction Outputs\n(UTXOs). So it is better to use the term unspent outputs rather than just\noutputs. Similarly, we add the amount in the UTXOs owned by an address to\ncalculate its balance. Signing a transaction basically adds the signature of the\nUTXO owners included in the inputs."}),"\n",(0,s.jsx)(n.p,{children:"If an account A wants to send 1.3 LUX to account B, then it has to include all\nthose unspent outputs in a transaction, that are owned by A and whose sum of\namounts in those outputs is more than or equal to 1.3. These UTXOs will be\nincluded as inputs in a transaction. Account A also has to create outputs with\namount 1.3 and the owner being the receiver (here B). There could be multiple\noutputs in the outputs array. This means, that using these UTXOs, we can create\nmultiple outputs with different amounts to different addresses."}),"\n",(0,s.jsx)(n.p,{children:"Once the transaction is committed, the UTXOs in the inputs will be consumed and\noutputs will become new UTXOs for the receiver. If the inputs have more amount\nunlocked than being consumed by the outputs, then the excess amount will be\nburned as fees. Therefore, we should also create a change output which will be\nassigned to us, if there is an excess amount in the input. In the diagram given\nbelow, a total of 1.72 LUX is getting unlocked in inputs, therefore we have\nalso created a change output for the excess amount (0.41 LUX) to the sender's\naddress. The remaining amount after being consumed by the outputs like\nreceiver's and change output, is burned as fees (0.01 LUX)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"multisig UTXOs 1",src:t(98236).A+"",width:"2884",height:"688"})}),"\n",(0,s.jsx)(n.h2,{id:"multi-signature-utxos",children:"Multi-Signature UTXOs"}),"\n",(0,s.jsxs)(n.p,{children:["UTXOs can be associated with multiple addresses. If there are multiple owners of\na UTXO, then we must note the ",(0,s.jsx)(n.code,{children:"threshold"})," value. We have to include signatures\nof a threshold number of UTXO owners with the unsigned transaction to consume\nUTXOs present in the inputs. The threshold value of a UTXO is set while issuing\nthe transaction."]}),"\n",(0,s.jsx)(n.p,{children:"We can use these multi-sig UTXOs as inputs for multiple purposes and not only\nfor sending assets. For example, we can use them to create Subnets, add\ndelegators, add validators, etc."}),"\n",(0,s.jsx)(n.h2,{id:"atomic-transactions",children:"Atomic Transactions"}),"\n",(0,s.jsxs)(n.p,{children:["On Lux, we can even create cross-chain outputs. This means that we can do\na native cross-chain transfer of assets. These are made possible through\n",(0,s.jsx)(n.strong,{children:"Atomic Transactions"}),". This is a 2-step process -"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Export transaction on source chain"}),"\n",(0,s.jsx)(n.li,{children:"Import transactions on the destination chain"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Atomic transactions are similar to other transactions. We use UTXOs of the\nsource chain as inputs and create outputs owned by destination chain addresses.\nWhen the export transactions are issued, the newly created UTXOs stay in the\n",(0,s.jsx)(n.strong,{children:"Exported Atomic Memory"}),". These are neither on the source chain nor on the\ndestination chain. These UTXOs can only be used as inputs by their owners on the\ndestination chain while making import transactions. Using these UTXOs on the\natomic memory, we can create multiple outputs with different amounts or\naddresses."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"multisig UTXOs 2",src:t(98871).A+"",width:"3682",height:"854"})}),"\n",(0,s.jsx)(n.h2,{id:"utxos-on-c-chain",children:"UTXOs on C-Chain"}),"\n",(0,s.jsx)(n.p,{children:"We can't use UTXOs on C-Chain to do regular transactions because C-Chain follows\nthe account-based approach. In C-Chain, each address (account) is mapped with\nits balance, and the assets are transferred simply by adding and subtracting\nfrom this balance using the virtual machine."}),"\n",(0,s.jsx)(n.p,{children:"But we can export UTXOs with one or multiple owners to C-Chain and then import\nthem by signing the transaction with the qualified spenders containing those\nUTXOs as inputs. The output on C-Chain can only have a single owner (a\nhexadecimal address). Similarly while exporting from C-Chain to other chains, we\ncan have multiple owners for the output, but input will be signed only by the\naccount whose balance is getting used."}),"\n",(0,s.jsx)(n.h2,{id:"getting-hands-on-multi-signature-utxos",children:"Getting Hands-on Multi-Signature UTXOs"}),"\n",(0,s.jsx)(n.p,{children:"Next, we will make utility and other helpful functions, so that, we can use them\nto create multi-sig UTXOs and spend them with ease. These functions will extract\ncommon steps into a function so that we do not have to follow each step every\ntime we are issuing a transaction."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["You can either follow the steps below to get a better understanding of\nconcepts and code or directly clone and test the examples from this\n",(0,s.jsx)(n.a,{href:"https://github.com/rajranjan0608/multisignature-utxos",children:"repo"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-project",children:"Setting Up Project"}),"\n",(0,s.jsxs)(n.p,{children:["Make a new directory ",(0,s.jsx)(n.code,{children:"multisig"})," for keeping all the project codes and move\nthere. First, let's install the required dependencies."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install --save @luxfi/luxjs dotenv\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now create a configuration file named ",(0,s.jsx)(n.code,{children:"config.js"})," for storing all the pieces of\ninformation regarding the network and chain we are connecting to. Since we are\nmaking transactions on the Testnet network, its network ID is 5. You can change the\nconfiguration according to the network you are using."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'require("dotenv").config();\n\nmodule.exports = {\n  protocol: "https",\n  ip: "api.lux-test.network",\n  port: 443,\n  networkID: 5,\n  privateKeys: JSON.parse(process.env.PRIVATEKEYS),\n  mnemonic: process.env.MNEMONIC,\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Create a ",(0,s.jsx)(n.code,{children:".env"})," file for storing sensitive information which we can't make\npublic like the private keys or the mnemonic. Here are the sample private keys,\nwhich you should not use. You can create a new account on ",(0,s.jsx)(n.a,{href:"https://support.lux.network/en/articles/6100129-core-extension-how-do-i-create-a-new-wallet",children:"Core extension"}),"\nand paste the mnemonic here for demonstration."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-env",children:'PRIVATEKEYS=`[\n    "PrivateKey-ewoqjP7PxY4yr3iLTpLisriqt94hdyDFNgchSxGGztUrTXtNN",\n    "PrivateKey-R6e8f5QSa89DjpvL9asNdhdJ4u8VqzMJStPV8VVdDmLgPd8a4"\n]`\nMNEMONIC="mask stand appear..."\n'})}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-apis-and-keychains",children:"Setting Up APIs and Keychains"}),"\n",(0,s.jsxs)(n.p,{children:["Create a file ",(0,s.jsx)(n.code,{children:"importAPI.js"})," for importing and setting up all the necessary\nAPIs, Keychains, addresses, etc. Now paste the following snippets into the file."]}),"\n",(0,s.jsx)(n.h3,{id:"importing-dependencies-and-configurations",children:"Importing Dependencies and Configurations"}),"\n",(0,s.jsx)(n.p,{children:"We need dependencies like the LuxJS module and other configurations. Let's import them at the top."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const { Lux, BinTools, BN } = require("lux");\nconst Web3 = require("web3");\n\nconst MnemonicHelper = require("lux/dist/utils/mnemonic").default;\nconst HDNode = require("lux/dist/utils/hdnode").default;\nconst { privateToAddress } = require("ethereumjs-util");\n\n// Importing node details and Private key from the config file.\nconst {\n  ip,\n  port,\n  protocol,\n  networkID,\n  privateKeys,\n  mnemonic,\n} = require("./config.js");\n\nlet { luxAssetID, chainIDs } = require("./constants.js");\n\n// For encoding and decoding to CB58 and buffers.\nconst bintools = BinTools.getInstance();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setup-lux-apis",children:"Setup Lux APIs"}),"\n",(0,s.jsx)(n.p,{children:"To make API calls to the Lux network and different blockchains like\nX-Chain, P-Chain and C-Chain, let's set up these by adding the following code\nsnippet."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Lux instance\nconst lux = new Lux(ip, port, protocol, networkID);\nconst nodeURL = `${protocol}://${ip}:${port}/ext/bc/C/rpc`;\nconst web3 = new Web3(nodeURL);\n\n// Platform and Lux API\nconst platform = lux.PChain();\nconst lux = lux.XChain();\nconst evm = lux.CChain();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setup-keychains-with-private-keys",children:"Setup Keychains with Private Keys"}),"\n",(0,s.jsx)(n.p,{children:"In order to sign transactions with our private keys, we will use the LuxJS\nkeychain API. This will locally store our private keys and can be easily used\nfor signing."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Keychain for signing transactions\nconst keyChains = {\n  x: lux.keyChain(),\n  p: platform.keyChain(),\n  c: evm.keyChain(),\n};\n\nfunction importPrivateKeys(privKey) {\n  keyChains.x.importKey(privKey);\n  keyChains.p.importKey(privKey);\n  keyChains.c.importKey(privKey);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can either use mnemonics to derive private keys from it or simply use the\nbare private key for importing keys to the keychain. We can use the following\nfunction to get private keys from the mnemonic and address index which we want.\nFor demo purposes, we will use addresses at index 0 and 1."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function getPrivateKey(mnemonic, activeIndex = 0) {\n  const mnemonicHelper = new MnemonicHelper();\n  const seed = mnemonicHelper.mnemonicToSeedSync(mnemonic);\n  const hdNode = new HDNode(seed);\n\n  const avaPath = `m/44'/9000'/0'/0/${activeIndex}`;\n\n  return hdNode.derive(avaPath).privateKeyCB58;\n}\n\n// importing keys in the key chain - use this if you have any private keys\n// privateKeys.forEach((privKey) => {\n// \timportPrivateKeys(privKey)\n// })\n\n// importing private keys from mnemonic\nimportPrivateKeys(getPrivateKey(mnemonic, 0));\nimportPrivateKeys(getPrivateKey(mnemonic, 1));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"setup-addresses-and-chain-ids",children:"Setup Addresses and Chain IDs"}),"\n",(0,s.jsxs)(n.p,{children:["For creating transactions we might need addresses of different formats like\n",(0,s.jsx)(n.code,{children:"Buffer"})," or ",(0,s.jsx)(n.code,{children:"Bech32"})," etc. And to make issue transactions on different chains we\nneed their ",(0,s.jsx)(n.code,{children:"chainID"}),". Paste the following snippet to achieve the same."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Buffer representation of addresses\nconst addresses = {\n  x: keyChains.x.getAddresses(),\n  p: keyChains.p.getAddresses(),\n  c: keyChains.c.getAddresses(),\n};\n\n// String representation of addresses\nconst addressStrings = {\n  x: keyChains.x.getAddressStrings(),\n  p: keyChains.p.getAddressStrings(),\n  c: keyChains.c.getAddressStrings(),\n};\n\nluxAssetID = bintools.cb58Decode(luxAssetID);\n\nchainIDs = {\n  x: bintools.cb58Decode(chainIDs.x),\n  p: bintools.cb58Decode(chainIDs.p),\n  c: bintools.cb58Decode(chainIDs.c),\n};\n\n// Exporting these for other files to use\nmodule.exports = {\n  networkID,\n  platform,\n  lux,\n  evm,\n  keyChains,\n  luxAssetID,\n  addresses,\n  addressStrings,\n  chainIDs,\n  bintools,\n  web3,\n  BN,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can use the above-exported variables and APIs from other files as required."}),"\n",(0,s.jsx)(n.h2,{id:"creating-utility-functions",children:"Creating Utility Functions"}),"\n",(0,s.jsxs)(n.p,{children:["While creating multi-sig transactions, we have a few things in common, like\ncreating inputs with the UTXOs, creating outputs, and adding signature indexes.\nSo let's create a file named ",(0,s.jsx)(n.code,{children:"utils.js"})," and paste the following snippets that we\ncan call every time we want to do a repetitive task."]}),"\n",(0,s.jsx)(n.h3,{id:"getting-dependencies",children:"Getting Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"Inputs and outputs are an array of transferable input and transferable output.\nThese contain transfer inputs and associated assetID which is being transferred.\nThere are different types of transfer inputs/outputs for sending assets, minting\nassets, minting NFTs, etc."}),"\n",(0,s.jsxs)(n.p,{children:["We will be using ",(0,s.jsx)(n.code,{children:"SECPTransferInput/SECPTransferOutput"})," for sending our assets."]}),"\n",(0,s.jsxs)(n.p,{children:["But since we can't use UTXOs on C-Chain, we cannot directly import them either.\nTherefore we need to create a different type of input/output for them called\n",(0,s.jsx)(n.code,{children:"EVMInput/EVMOutput"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const { BN, chainIDs, web3 } = require("./importAPI");\n\nlet SECPTransferInput,\n  TransferableInput,\n  SECPTransferOutput,\n  TransferableOutput,\n  EVMInput,\n  EVMOutput;\n\nconst getTransferClass = (chainID) => {\n  let vm = "";\n  if (chainID.compare(chainIDs.x) == 0) {\n    vm = "avm";\n  } else if (chainID.compare(chainIDs.p) == 0) {\n    vm = "platformvm";\n  } else if (chainID.compare(chainIDs.c) == 0) {\n    vm = "evm";\n  }\n  return ({\n    SECPTransferInput,\n    TransferableInput,\n    SECPTransferOutput,\n    TransferableOutput,\n    EVMInput,\n    EVMOutput,\n    index,\n  } = require(`lux/dist/apis/${vm}/index`));\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Different chains have their own implementation of TransferInput/Output classes.\nTherefore we need to update the required modules according to the chain we\nissuing transactions on. To make it more modular, we created a\n",(0,s.jsx)(n.code,{children:"getTransferClass()"})," function, that will take ",(0,s.jsx)(n.code,{children:"chainID"})," and import modules as\nrequired."]}),"\n",(0,s.jsx)(n.h3,{id:"creating-transferable-output",children:"Creating Transferable Output"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"createOutput()"})," function will create and return the transferable output\naccording to arguments amount, assetID, owner addresses, lock time, and\nthreshold. Lock time represents the timestamp after which this output could be\nspent. Mostly this parameter will be 0."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const createOutput = (amount, assetID, addresses, locktime, threshold) => {\n  let transferOutput = new SECPTransferOutput(\n    amount,\n    addresses,\n    locktime,\n    threshold\n  );\n\n  return new TransferableOutput(assetID, transferOutput);\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-transferable-input",children:"Creating Transferable Input"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"createInput()"})," function will create and return transferable input. Input\nrequire arguments like amount in the UTXO, and arguments which identify that\nUTXO, like txID of the transaction which the UTXO was the output of, ",(0,s.jsx)(n.code,{children:"outputIndex"}),"\n(index of the output in that TX), and qualified signatures (output spenders\nwhich are present in our keychain) whose signature will be required while\nsigning this transaction."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const createInput = (\n  amount,\n  txID,\n  outputIndex,\n  assetID,\n  spenders,\n  threshold\n) => {\n  // creating transfer input\n  let transferInput = new SECPTransferInput(amount);\n\n  // adding threshold signatures\n  addSignatureIndexes(spenders, threshold, transferInput);\n\n  // creating transferable input\n  return new TransferableInput(txID, outputIndex, assetID, transferInput);\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"add-signature-indexes",children:"Add Signature Indexes"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"createSignatureIndexes()"})," function will add spender addresses along with an\nindex for each address in the transfer input. While signing the unsigned\ntransaction, these signature indexes will be used."]}),"\n",(0,s.jsxs)(n.p,{children:["By adding signature indexes we are not signing the inputs but just adding a\nplaceholder of the address at a particular index whose signature is required\nwhen we call the ",(0,s.jsx)(n.code,{children:".sign()"})," function on the unsigned transactions. Once the\nthreshold spender addresses are added, it will exit."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const addSignatureIndexes = (addresses, threshold, input) => {\n  let sigIndex = 0;\n  addresses.every((address) => {\n    if (threshold > 0) {\n      input.addSignatureIdx(sigIndex, address);\n      sigIndex++;\n      threshold--;\n      return true;\n    } else {\n      return false;\n    }\n  });\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"create-evm-input",children:"Create EVM Input"}),"\n",(0,s.jsxs)(n.p,{children:["As explained earlier, we do not have UTXOs on C-Chain. Therefore we cannot make\nregular inputs. The following function ",(0,s.jsx)(n.code,{children:"createEVMInput()"})," will create the\nrequired input and add a signature index corresponding to the address specified\nin the input."]}),"\n",(0,s.jsxs)(n.p,{children:["EVM Inputs are required when we want to export assets from C-Chain. In the\nfollowing function, ",(0,s.jsx)(n.code,{children:"addresses"})," is the array of Buffer addresses but for\n",(0,s.jsx)(n.code,{children:"C-Chain Export Transactions"}),", a hex address is also appended at last."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const createEVMInput = (amount, addresses, assetID, nonce) => {\n  const hexAddress = addresses.at(-1);\n  const evmInput = new EVMInput(hexAddress, amount, assetID, nonce);\n  evmInput.addSignatureIdx(0, addresses[0]);\n\n  return evmInput;\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"create-evm-output",children:"Create EVM Output"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"createEVMOutput()"})," function will create EVM output for importing assets on C-Chain."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const createEVMOutput = (amount, hexAddress, assetID) => {\n  return new EVMOutput(hexAddress, amount, assetID);\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"update-transfer-class",children:"Update Transfer Class"}),"\n",(0,s.jsxs)(n.p,{children:["Let's make a small function that will call the ",(0,s.jsx)(n.code,{children:"getTransferClass()"})," according to the ",(0,s.jsx)(n.code,{children:"chainID"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const updateTransferClass = (chainID) => {\n  {\n    SECPTransferInput,\n      TransferableInput,\n      SECPTransferOutput,\n      TransferableOutput,\n      EVMInput,\n      EVMOutput,\n      (index = getTransferClass(chainID));\n  }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"add-utxos-to-inputs",children:"Add UTXOs to Inputs"}),"\n",(0,s.jsxs)(n.p,{children:["We have ",(0,s.jsx)(n.code,{children:"inputs"})," as an array of UTXOs that will be consumed in the transaction.\nThe ",(0,s.jsx)(n.code,{children:"updateInputs()"})," function will take UTXOs, ",(0,s.jsx)(n.code,{children:"addresses"})," whose credentials we\nhave for signing, ",(0,s.jsx)(n.code,{children:"assetID"})," and ",(0,s.jsx)(n.code,{children:"toBeUnlocked"})," that is amount we want to consume.\n",(0,s.jsx)(n.code,{children:"toBeUnlocked"})," contains everything we want to consume including transfer amount,\nfees, stake amount (if any), etc."]}),"\n",(0,s.jsxs)(n.p,{children:["We also have a special variable ",(0,s.jsx)(n.code,{children:"C"}),", that will indicate the type of transaction\nwhich is associated with the C-Chain. This is required because -"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Export from C-Chain (C.export == true) - These types of transactions cannot\nhave UTXOs as inputs and therefore ",(0,s.jsx)(n.code,{children:"EVMInput"})," is created."]}),"\n",(0,s.jsxs)(n.li,{children:["Import to C-Chain (C.import == true) - The outputs imported on C-Chain from exported UTXOs are ",(0,s.jsx)(n.code,{children:"EVMOutput"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It will create inputs with the passed UTXOs worth the ",(0,s.jsx)(n.code,{children:"toBeUnlocked"})," amount. But\nif there is a UTXO that when included, will surpass the ",(0,s.jsx)(n.code,{children:"toBeUnlocked"})," amount,\nthen it will create a change output with the qualified spenders as their new\nowners with the surpassed amount."]}),"\n",(0,s.jsxs)(n.p,{children:["This function will return the ",(0,s.jsx)(n.code,{children:"inputs"})," array containing all the unlocked UTXOs,\nchange transferable output, and the net balance included in these inputs. Now\nadd the following function snippet."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const updateInputs = async (\n  utxos,\n  addresses,\n  C,\n  assetID,\n  toBeUnlocked,\n  chainID\n) => {\n  // Getting transferable inputs according to chain id\n  updateTransferClass(chainID);\n\n  let inputs = [],\n    changeTransferableOutput = undefined,\n    netInputBalance = new BN(0);\n\n  if (C.export) {\n    const nonce = await web3.eth.getTransactionCount(addresses.at(-1));\n    inputs.push(createEVMInput(toBeUnlocked, addresses, assetID, nonce));\n  } else {\n    utxos.forEach((utxo) => {\n      let output = utxo.getOutput();\n      if (\n        output.getOutputID() === 7 &&\n        assetID.compare(utxo.getAssetID()) === 0 &&\n        netInputBalance < toBeUnlocked\n      ) {\n        let outputThreshold = output.getThreshold();\n\n        // spenders which we have in our keychain\n        let qualifiedSpenders = output.getSpenders(addresses);\n\n        // create inputs only if we have custody of threshold or more number of utxo spenders\n        if (outputThreshold <= qualifiedSpenders.length) {\n          let txID = utxo.getTxID();\n          let outputIndex = utxo.getOutputIdx();\n          let utxoAmount = output.amountValue;\n          let outputLocktime = output.getLocktime();\n\n          netInputBalance = netInputBalance.add(utxoAmount);\n\n          let excessAmount = netInputBalance.sub(toBeUnlocked);\n\n          // creating change transferable output\n          if (excessAmount > 0) {\n            if (!C.import) {\n              changeTransferableOutput = createOutput(\n                excessAmount,\n                assetID,\n                qualifiedSpenders,\n                outputLocktime,\n                outputThreshold\n              );\n            }\n          }\n\n          // create transferable input\n          let transferableInput = createInput(\n            utxoAmount,\n            txID,\n            outputIndex,\n            assetID,\n            qualifiedSpenders,\n            outputThreshold\n          );\n\n          inputs.push(transferableInput);\n        }\n      }\n    });\n  }\n  return { inputs, changeTransferableOutput };\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Only those UTXOs will be included whose output ID is ",(0,s.jsx)(n.code,{children:"7"})," representing\n",(0,s.jsx)(n.code,{children:"SECPTransferOutput"}),". These outputs are used for transferring assets. Also, we\nare only including outputs containing ",(0,s.jsx)(n.code,{children:"LUX"})," assets. These conditions are\nchecked in the following line -"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"if(output.getOutputID() === 7 && assetID.compare(utxo.getAssetID()) === 0 && netInputBalance < toBeUnlocked) {\n"})}),"\n",(0,s.jsx)(n.p,{children:"The following part in the above function creates the change output if the total\nincluded balance surpasses the required amount and the transaction is not a\nC-Chain export -"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"netInputBalance = netInputBalance.add(utxoAmount);\n\nlet excessAmount = netInputBalance.sub(toBeUnlocked);\n\n// creating change transferable output\nif (excessAmount > 0) {\n  if (!C.import) {\n    changeTransferableOutput = createOutput(\n      excessAmount,\n      assetID,\n      qualifiedSpenders,\n      outputLocktime,\n      outputThreshold\n    );\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"export-utility-functions",children:"Export Utility Functions"}),"\n",(0,s.jsx)(n.p,{children:"Now paste the following snippet to export these utility functions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  createOutput,\n  createEVMOutput,\n  updateInputs,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"All the utility functions are created."}),"\n",(0,s.jsx)(n.h2,{id:"create-inputs-and-outputs",children:"Create Inputs and Outputs"}),"\n",(0,s.jsx)(n.p,{children:"Let's create a function that will return the array of sufficient UTXOs stuffed\ninside an array and necessary outputs like send output, multi-sig output, evm\noutput, change output, etc. This function is basically a wrapper that\norchestrates the utility and other functions to generate inputs and outputs from\nparameters like addresses, asset id, chain id, output arguments (to, threshold\nand amount), etc."}),"\n",(0,s.jsxs)(n.p,{children:["Now make a new file ",(0,s.jsx)(n.code,{children:"createInputsAndOutputs.js"})," and paste the following snippets of code inside it."]}),"\n",(0,s.jsx)(n.h3,{id:"importing-dependencies",children:"Importing Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"We need to import utility functions for creating outputs and inputs with the UTXOs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const { BN, lux, platform, evm, chainIDs, bintools } = require("./importAPI");\n\nconst { createOutput, createEVMOutput, updateInputs } = require("./utils");\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EVMInput"})," should be used as inputs while creating an export transaction from\nC-Chain and ",(0,s.jsx)(n.code,{children:"EVMOutput"})," should be used as outputs while creating an import\ntransaction on C-Chain. To make it easier to decide when to do what, let's make\na function ",(0,s.jsx)(n.code,{children:"checkChain()"})," that will return an object ",(0,s.jsx)(n.code,{children:"C"})," (described earlier)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const checkChain = (chainID, ownerAddress) => {\n  let C = {\n    export: false,\n    import: false,\n  };\n  if (chainID.compare(chainIDs.c) == 0) {\n    if (typeof ownerAddress == "string" && bintools.isHex(ownerAddress)) {\n      C.import = true;\n    } else {\n      C.export = true;\n    }\n  }\n  return C;\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For getting UTXOs from an address, let's make another function\n",(0,s.jsx)(n.code,{children:"getUnspentOutputs()"}),". This function will fetch UTXOs from a given address and\nsource chain. The ",(0,s.jsx)(n.code,{children:"sourceChain"})," will be used to fetch exported UTXOs that are\nnot yet imported. The exported outputs stay in the exported atomic memory. This\nparameter will only be used when we want to import assets."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// UTXOs for spending unspent outputs\nconst getUnspentOutputs = async (\n  addresses,\n  chainID,\n  sourceChain = undefined\n) => {\n  let utxoSet;\n  if (chainID.compare(chainIDs.x) == 0) {\n    utxoSet = await lux.getUTXOs(addresses, sourceChain);\n  } else if (chainID.compare(chainIDs.p) == 0) {\n    utxoSet = await platform.getUTXOs(addresses, sourceChain);\n  }\n  return utxoSet.utxos.getAllUTXOs();\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now for organizing inputs and outputs and adding required signature indexes (not\nsignatures) for each unspent output, adding change output, etc, we will make a\n",(0,s.jsx)(n.code,{children:"createInputsAndOutputs()"})," function. Paste the following snippet next."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const createInputsAndOutputs = async (\n  assetID,\n  chainID,\n  addresses,\n  addressStrings,\n  outputConfig,\n  fee,\n  sourceChain\n) => {\n  let locktime = new BN(0);\n\n  let C = checkChain(chainID, outputConfig[0].owners);\n\n  let utxos = [];\n  if (C.export) {\n    addresses.push("0x3b0e59fc2e9a82fa5eb3f042bc5151298e4f2cab"); // getHexAddress(addresses[0])\n  } else {\n    utxos = await getUnspentOutputs(addressStrings, chainID, sourceChain);\n  }\n\n  let toBeUnlocked = fee;\n  outputConfig.forEach((output) => {\n    toBeUnlocked = toBeUnlocked.add(output.amount);\n  });\n\n  // putting right utxos in the inputs\n  let { inputs, changeTransferableOutput } = await updateInputs(\n    utxos,\n    addresses,\n    C,\n    assetID,\n    toBeUnlocked,\n    chainID\n  );\n\n  let outputs = [];\n\n  // creating transferable outputs and transfer outputs\n  outputConfig.forEach((output) => {\n    let newOutput;\n    if (!C.import) {\n      newOutput = createOutput(\n        output.amount,\n        assetID,\n        output.owners,\n        locktime,\n        output.threshold\n      );\n    } else {\n      newOutput = createEVMOutput(output.amount, output.owners, assetID);\n    }\n    outputs.push(newOutput);\n  });\n\n  // pushing change output (if any)\n  if (changeTransferableOutput != undefined && !C.import) {\n    outputs.push(changeTransferableOutput);\n  }\n\n  return { inputs, outputs };\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Output config is basically an array of all outputs that we want to create. This\nexcludes the change output because it will be automatically created. It has the\nfollowing structure."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Regular outputs\n[\n  {\n    amount: BigNumber,\n    owners: [Buffer],\n    threshold: Number,\n  },\n][\n  // Import to C-Chain\n  {\n    amount: BigNumber,\n    owners: "hex address string",\n  }\n];\n'})}),"\n",(0,s.jsx)(n.p,{children:"You will learn about these arguments and how we can actually pass this along\nwith other arguments through the examples ahead."}),"\n",(0,s.jsx)(n.h3,{id:"exporting-functions",children:"Exporting Functions"}),"\n",(0,s.jsx)(n.p,{children:"Add the following snippet to export this function."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  createInputsAndOutputs,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"We have created all the utility and helper functions. You can use this project\nstructure to create different types of transactions like BaseTx, Export, Import,\nAddDelegator, etc. You should have the following files in your project now -"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:".env"})," - Secret file storing data like mnemonic and private keys"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"config.js"})," - Network information and parsed data from ",(0,s.jsx)(n.code,{children:".env"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"constants.js"})," - Asset and Chain specific static data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"importAPI.js"})," - Import and setup apis, addresses and keychains"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"utils.js"})," - Utility functions for creating inputs and outputs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"createInputsAndOutputs.js"})," - Wrapper of ",(0,s.jsx)(n.code,{children:"utility.js"})," for orchestrating utility functions."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Follow the next steps for ",(0,s.jsx)(n.strong,{children:"examples"})," and on how to use these functions."]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(n.p,{children:["Now let's look at the examples for executing these transactions. For example, we\nwill create a separate ",(0,s.jsx)(n.code,{children:"examples"})," folder. In order to run the example scripts,\nyou must be in the root folder where all the environment variables and\nconfigurations are kept."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node examples/send.js\n"})}),"\n",(0,s.jsx)(n.h2,{id:"multi-signature-base-tx-on-x-chain",children:"Multi-Signature Base TX on X-Chain"}),"\n",(0,s.jsxs)(n.p,{children:["Let's create a base transaction that converts a single-owner UTXO into a\nmulti-sig UTXO. The final UTXO can be used by new owners of the unspent output\nby adding their signatures for each output. Create a new file ",(0,s.jsx)(n.code,{children:"sendBaseTx.js"}),"\nand paste the following snippets."]}),"\n",(0,s.jsx)(n.h3,{id:"import-dependencies",children:"Import Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["Import the necessary dependencies like ",(0,s.jsx)(n.code,{children:"keyChains"}),", ",(0,s.jsx)(n.code,{children:"addresses"}),", ",(0,s.jsx)(n.code,{children:"utility"}),"\nfunctions, ",(0,s.jsx)(n.code,{children:"UnSignedTx"})," and ",(0,s.jsx)(n.code,{children:"BaseTx"})," classes etc."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  lux,\n} = require("../importAPI");\n\nconst { UnsignedTx, BaseTx } = require("lux/dist/apis/avm/index");\n\nconst { createInputsAndOutputs } = require("../createMultisig");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"send-basetx",children:"Send BaseTx"}),"\n",(0,s.jsxs)(n.p,{children:["Now create the ",(0,s.jsx)(n.code,{children:"sendBaseTx()"})," function to be called for sending base TX to the network."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function sendBaseTx() {\n  let memo = Buffer.from("Multisig Base Tx");\n\n  // unlock amount = sum(output amounts) + fee\n  let fee = new BN(1e6);\n\n  // creating outputs of 0.5 (multisig) and 0.1 LUX - change output will be added by the function in the last\n  let outputConfig = [\n    {\n      amount: new BN(5e8),\n      owners: addresses.x,\n      threshold: 2,\n    },\n    {\n      amount: new BN(1e8),\n      owners: [addresses.x[1]],\n      threshold: 1,\n    },\n  ];\n\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.x,\n    addresses.x,\n    addressStrings.x,\n    outputConfig,\n    fee\n  );\n\n  const baseTx = new BaseTx(networkID, chainIDs.x, outputs, inputs, memo);\n\n  const unsignedTx = new UnsignedTx(baseTx);\n  const tx = unsignedTx.sign(keyChains.x);\n  const txID = await lux.issueTx(tx);\n  console.log("TxID:", txID);\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"We have created the BaseTx with the following output configuration -"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Multi-sig output of value 0.5 LUX with threshold 2 and owners represented by\n",(0,s.jsx)(n.code,{children:"addresses.x"}),". The owners are basically an array of addresses in Buffer\nrepresentation."]}),"\n",(0,s.jsx)(n.li,{children:"Single owner output of value 0.1 LUX."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let outputConfig = [\n  {\n    amount: new BN(5e8),\n    owners: addresses.x,\n    threshold: 2,\n  },\n  {\n    amount: new BN(1e8),\n    owners: [addresses.x[1]],\n    threshold: 1,\n  },\n];\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's discuss the arguments of ",(0,s.jsx)(n.code,{children:"createInputsAndOutputs()"})," in detail -"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"assetID"})," - ID of the asset involved in transaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"chainID"})," - ID of the chain on which this transaction will be issued"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"addresses"})," - Addresses buffer array whose UTXO will be consumed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"addressStrings"})," - Addresses string array whose UTXO will be consumed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"outputConfig"})," - Array of output object containing amount, owners and threshold"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fee"})," - Fee for this transaction to be consumed in inputs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sourceChain"})," - Chain from which UTXOs will be fetched. Will take ",(0,s.jsx)(n.code,{children:"chainID"})," as default."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In the above parameters, if ",(0,s.jsx)(n.code,{children:"fee"})," is less than the fees actually required for\nthat transaction, then there will be no surplus amount left by outputs over\ninputs because any surplus will be converted into a change output. This can\ncause transaction failure. So keep the fees in accordance with the transaction\nas mentioned ",(0,s.jsx)(n.a,{href:"/reference/standards/guides/txn-fees#fee-schedule",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Also, the ",(0,s.jsx)(n.code,{children:"sourceChain"})," parameter is required for fetching exported UTXOs that\ndo not exist yet on the destination chain. For non-export/import transactions,\nthis parameter is not required."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"createInputsAndOutputs()"})," function will return ",(0,s.jsx)(n.code,{children:"inputs"})," and ",(0,s.jsx)(n.code,{children:"outputs"}),"\nrequired for any transaction. The last element of the outputs array would be\nchange output. And the order of other outputs will be the same as that in the\n",(0,s.jsx)(n.code,{children:"outputConfig"}),". Signature indexes corresponding to their owners are already\nincluded in the inputs. We can create an unsigned base transaction using the\n",(0,s.jsx)(n.code,{children:"BaseTx"})," and ",(0,s.jsx)(n.code,{children:"UnsignedTx"})," classes as shown above. The ",(0,s.jsx)(n.code,{children:".sign()"})," function\nbasically adds the required signatures from the keychain at the place indicated\nby signature indexes."]}),"\n",(0,s.jsxs)(n.p,{children:["Once the multi-sig UTXO is created, this UTXO can only be used if we have the\nthreshold signers in our keychain. The ",(0,s.jsx)(n.code,{children:"util"})," functions can be tweaked a little\nbit to create and return inputs with a part number of signers (less than threshold). We\ncan then partially sign the inputs and ask other owners to add signature index\nand sign."]}),"\n",(0,s.jsxs)(n.p,{children:["Now call the ",(0,s.jsx)(n.code,{children:"sendBaseTx()"})," function by adding this line"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"sendBaseTx();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Run this file using ",(0,s.jsx)(n.code,{children:"node examples/sendBaseTx.js"}),", see the txID in the output,\nand look for it in the Testnet explorer."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"multisig UTXOs 3",src:t(14535).A+"",width:"2901",height:"1149"})}),"\n",(0,s.jsx)(n.h2,{id:"export-multi-sig-utxo-from-x-to-p-chain",children:"Export Multi-Sig UTXO From X to P-Chain"}),"\n",(0,s.jsx)(n.p,{children:"Now we will look into exporting assets from the X to P chain. It will be similar\nto the BaseTx example, with few differences in output ordering and cross-chain\nowner addresses."}),"\n",(0,s.jsxs)(n.p,{children:["Make a new file named ",(0,s.jsx)(n.code,{children:"exportXP.js"})," and paste the following snippets."]}),"\n",(0,s.jsx)(n.h3,{id:"import-dependencies-1",children:"Import Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["This time we will require ",(0,s.jsx)(n.code,{children:"ExportTx"})," instead of ",(0,s.jsx)(n.code,{children:"BaseTx"})," class."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  lux,\n} = require("../importAPI");\n\nconst { UnsignedTx, ExportTx } = require("lux/dist/apis/avm/index");\n\nconst { createInputsAndOutputs } = require("../createMultisig");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"send-export-transaction",children:"Send Export Transaction"}),"\n",(0,s.jsxs)(n.p,{children:["Most of the things will be very much similar in this function. You can have a\nlook at ",(0,s.jsx)(n.code,{children:"outputConfig"}),", which creates a multi-sig output for addresses on\nP-Chain. These addresses will be required for signing ",(0,s.jsx)(n.code,{children:"importTx"})," on P-Chain."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"fee"})," here will only be for exporting the asset. The import fees will be\ndeducted from the UTXOs present on the ",(0,s.jsx)(n.strong,{children:"Exported Atomic Memory"}),", a memory\nlocation where UTXOs lie after getting exported but before being imported. If\nthere is only a single UTXO, then it will be deducted from it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function exportXP() {\n  let memo = Buffer.from("Multisig Export Tx");\n\n  // consuming amount = sum(output amount) + fee\n  let fee = new BN(1e6);\n\n  // creates mutlti-sig (0.1 LUX) and single-sig (0.03 LUX) output for exporting to P Address (0.001 LUX will be fees)\n  let outputConfig = [\n    {\n      amount: new BN(3e6),\n      owners: [addresses.p[0]],\n      threshold: 1,\n    },\n    {\n      amount: new BN(1e8),\n      owners: addresses.p,\n      threshold: 2,\n    },\n  ];\n\n  // importing fees will be deducted from these our other outputs in the exported output memory\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.x,\n    addresses.x,\n    addressStrings.x,\n    outputConfig,\n    fee\n  );\n\n  // outputs at index 0 and 1 are to be exported\n  const exportTx = new ExportTx(\n    networkID,\n    chainIDs.x,\n    [outputs.at(-1)],\n    inputs,\n    memo,\n    chainIDs.p,\n    [outputs[0], outputs[1]]\n  );\n\n  const unsignedTx = new UnsignedTx(exportTx);\n  const tx = unsignedTx.sign(keyChains.x);\n  const txID = await lux.issueTx(tx);\n  console.log("TxID:", txID);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Another point to note is how inputs, outputs, and ",(0,s.jsx)(n.code,{children:"exportedOutputs"})," are passed here."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Inputs are as usual passed for the ",(0,s.jsx)(n.code,{children:"ins"})," parameter of the ",(0,s.jsx)(n.code,{children:"ExportTx"})," class."]}),"\n",(0,s.jsxs)(n.li,{children:["But only ",(0,s.jsx)(n.code,{children:"outputs. at(-1)"})," representing change output (last element) is passed\nin place of the usual ",(0,s.jsx)(n.code,{children:"outs"})," parameter."]}),"\n",(0,s.jsxs)(n.li,{children:["The last parameter of this class is ",(0,s.jsx)(n.code,{children:"exportedOuts"}),", representing the outputs that\nwill be exported from this chain to ",(0,s.jsx)(n.code,{children:"destinationChain"})," (2nd last parameter)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"All these inputs and outputs are array, and hence con contains multiple outputs\nor inputs. But you have to manage which output should be passed where."}),"\n",(0,s.jsx)(n.p,{children:"Call the function by adding the below function call."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"exportXP();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Run this file using ",(0,s.jsx)(n.code,{children:"node examples/exportXP.js"}),", see the txID in the output, and\nlook for it in the ",(0,s.jsx)(n.a,{href:"https://explorer-xp.lux-test.network/blockchain/2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm",children:"Testnet\nexplorer"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"multisig UTXOs 4",src:t(68350).A+"",width:"2899",height:"1297"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above image, we are consuming UTXO with the amount ",(0,s.jsx)(n.code,{children:"0.486..."}),", and\ngenerating outputs with the amount ",(0,s.jsx)(n.code,{children:"0.382..."})," (change output) and ",(0,s.jsx)(n.code,{children:"0.003"})," and\n",(0,s.jsx)(n.code,{children:"0.1"})," (exported output). The remaining ",(0,s.jsx)(n.code,{children:"0.001"})," is burned as transaction fees."]}),"\n",(0,s.jsx)(n.h2,{id:"import-multi-sig-utxo-from-x-to-p-chain",children:"Import Multi-Sig UTXO From X to P-Chain"}),"\n",(0,s.jsxs)(n.p,{children:["After exporting the UTXOs from the source chain, it stays in the exported atomic\nmemory that is these are neither on the source chain nor on the destination chain.\nPaste the following snippets into a new file ",(0,s.jsx)(n.code,{children:"importP.js"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"import-dependencies-2",children:"Import Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["We will require ",(0,s.jsx)(n.code,{children:"ImportTx"})," from PlatformVM APIs."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  platform,\n} = require("../importAPI");\n\nconst {\n  UnsignedTx,\n  ImportTx,\n} = require("lux/dist/apis/platformvm/index");\n\nconst { createInputsAndOutputs } = require("../createMultisig");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"send-import-transaction",children:"Send Import Transaction"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"importP()"})," is a simple function that will use UTXOs on the exported atomic\nmemory as its inputs and create an output on the P-Chain addresses. You can\nchange the output config's owners and amount as per your need."]}),"\n",(0,s.jsxs)(n.p,{children:["An important point to note here is that all UTXOs that are included in this\n",(0,s.jsx)(n.code,{children:"importTx"})," will be transferred to the destination chain. Even if the import\namount is less than the amount in the UTXO, it will be sent to the qualified\nspender on the destination chain as a change output."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function importP() {\n  let memo = Buffer.from("Multisig Import Tx");\n\n  // Use this parameter if you have UTXOs exported from other chains - only exported outputs will be fetched\n  let sourceChain = "X";\n\n  // unlock amount = sum(output amount) + fee\n  let fee = new BN(1e6);\n\n  let outputConfig = [\n    {\n      amount: new BN(1e6),\n      owners: addresses.p,\n      threshold: 2,\n    },\n    {\n      amount: new BN(1e2),\n      owners: addresses.p[0],\n      threshold: 1,\n    },\n  ];\n\n  // all the inputs here are the exported ones due to source chain parameter\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.p,\n    addresses.p,\n    addressStrings.p,\n    outputConfig,\n    fee,\n    sourceChain\n  );\n\n  const importTx = new ImportTx(\n    networkID,\n    chainIDs.p,\n    outputs,\n    [],\n    memo,\n    chainIDs.x,\n    inputs\n  );\n\n  const unsignedTx = new UnsignedTx(importTx);\n  const tx = unsignedTx.sign(keyChains.x);\n  const txID = await platform.issueTx(tx);\n  console.log("TxID:", txID);\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"multisig UTXOs 5",src:t(77189).A+"",width:"2923",height:"1393"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above image, we are consuming the above exported UTXOs with amounts\n",(0,s.jsx)(n.code,{children:"0.003"})," and ",(0,s.jsx)(n.code,{children:"0.1"}),", and generating outputs with amount ",(0,s.jsx)(n.code,{children:"0.092..."})," (change output\nimported on P-Chain) and 2 ",(0,s.jsx)(n.code,{children:"0.005"})," imported outputs (1 multi-sig and 1\nsingle-sig). The remaining ",(0,s.jsx)(n.code,{children:"0.001"})," is burned as transaction fees."]}),"\n",(0,s.jsx)(n.h2,{id:"import-multi-sig-utxo-from-x-to-c-chain",children:"Import Multi-Sig UTXO From X to C-Chain"}),"\n",(0,s.jsxs)(n.p,{children:["This transaction will also be similar to other atomic transactions, except for\nthe ",(0,s.jsx)(n.code,{children:"outputConfig"})," parameter. You can easily get the idea by looking at the code\nbelow. Before you can run this example, there must be exported outputs for the\naddresses you control on the C-Chain, otherwise, there will be no UTXO to\nconsume."]}),"\n",(0,s.jsx)(n.p,{children:"Here we are importing UTXOs that are exported from X-Chain."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  evm,\n} = require("../importAPI");\n\nconst { UnsignedTx, ImportTx } = require("lux/dist/apis/evm/index");\n\nconst { createInputsAndOutputs } = require("../createMultisig");\n\nasync function importP() {\n  // Use this parameter if you have UTXOs exported from other chains - only exported outputs will be fetched\n  let sourceChain = "X";\n\n  // unlock amount = sum(output amount) + fee (fees on C-Chain is dynamic)\n  let fee = new BN(0);\n\n  let outputConfig = [\n    {\n      amount: new BN(1e4),\n      owners: "0x4406a53c35D05424966bD8FC354E05a3c6B56aF0",\n    },\n    {\n      amount: new BN(2e4),\n      owners: "0x3b0e59fc2e9a82fa5eb3f042bc5151298e4f2cab",\n    },\n  ];\n\n  // all the inputs here are the exported ones due to source chain parameter\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.c,\n    addresses.c,\n    addressStrings.c,\n    outputConfig,\n    fee,\n    sourceChain\n  );\n\n  const importTx = new ImportTx(\n    networkID,\n    chainIDs.c,\n    chainIDs.x,\n    inputs,\n    outputs\n  );\n\n  const unsignedTx = new UnsignedTx(importTx);\n  const tx = unsignedTx.sign(keyChains.x);\n  const txID = await evm.issueTx(tx);\n  console.log("TxID:", txID);\n}\n\nimportP();\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"multisig UTXOs 6",src:t(98195).A+"",width:"2977",height:"635"})}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.a,{href:"https://testnet.avascan.info/",children:"Avascan"})," to view import and export transactions on C-Chain."]}),"\n",(0,s.jsx)(n.h2,{id:"add-delegator-transaction",children:"Add Delegator Transaction"}),"\n",(0,s.jsx)(n.p,{children:"Till now we have covered common transactions like BaseTx, Export, and Import TX.\nExport and Import TX will be similar in all the UTXO-based chains like X and P.\nBut for Account-based chains, we have to deal with an account-balance system."}),"\n",(0,s.jsxs)(n.p,{children:["Now let's try using the multi-sig UTXOs exported from X-Chain to P-Chain to\nissue an ",(0,s.jsx)(n.code,{children:"addDelegator()"})," transaction. Create a file ",(0,s.jsx)(n.code,{children:"addDelegatorTx.js"})," and\npaste the following snippets."]}),"\n",(0,s.jsx)(n.h3,{id:"import-dependencies-3",children:"Import Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["Import the dependencies like ",(0,s.jsx)(n.code,{children:"AddDelegatorTx"})," and ",(0,s.jsx)(n.code,{children:"UnsignedTx"})," classes using the following code."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const {\n  luxAssetID,\n  keyChains,\n  chainIDs,\n  addresses,\n  addressStrings,\n  networkID,\n  BN,\n  platform,\n} = require("../importAPI");\n\nconst {\n  UnsignedTx,\n  AddDelegatorTx,\n  SECPOwnerOutput,\n  ParseableOutput,\n} = require("lux/dist/apis/platformvm/index");\n\nconst { NodeIDStringToBuffer, UnixNow } = require("lux/dist/utils");\n\nconst { createInputsAndOutputs } = require("../createMultisig");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"sending-adddelegator-transaction",children:"Sending AddDelegator Transaction"}),"\n",(0,s.jsxs)(n.p,{children:["Now we will create the ",(0,s.jsx)(n.code,{children:"addDelegator()"})," function which will use the multi-sig\nUTXOs and create a signed ",(0,s.jsx)(n.code,{children:"addDelegatorTx"}),", which when issued, will add the\ndelegator to the specified node. Paste the following snippet next."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function addDelegator() {\n  let nodeID = NodeIDStringToBuffer("NodeID-4B4rc5vdD1758JSBYL1xyvE5NHGzz6xzH");\n  let locktime = new BN(0);\n  let stakeAmount = await platform.getMinStake();\n  let startTime = UnixNow().add(new BN(60 * 1));\n  let endTime = startTime.add(new BN(2630000));\n  let memo = Buffer.from("Multi-sig Add Delegator Tx");\n\n  // unlock amount = sum(output amounts) + fee\n  let fee = new BN(1e6);\n\n  // creating stake amount output at 0th index\n  let outputConfig = [\n    {\n      amount: stakeAmount.minValidatorStake,\n      owners: addresses.p,\n      threshold: 2,\n    },\n  ];\n\n  // outputs to be created for rewards\n  const rewardOutputOwners = new SECPOwnerOutput(addresses.p, locktime, 2);\n  const rewardOwners = new ParseableOutput(rewardOutputOwners);\n\n  let { inputs, outputs } = await createInputsAndOutputs(\n    luxAssetID,\n    chainIDs.p,\n    addresses.p,\n    addressStrings.p,\n    outputConfig,\n    fee\n  );\n\n  const addDelegatorTx = new AddDelegatorTx(\n    networkID,\n    chainIDs.p,\n    [],\n    inputs,\n    memo,\n    nodeID,\n    startTime,\n    endTime,\n    stakeAmount.minDelegatorStake,\n    [outputs[0]],\n    rewardOwners\n  );\n\n  const unsignedTx = new UnsignedTx(addDelegatorTx);\n  const tx = unsignedTx.sign(keyChains.p);\n  const txID = await platform.issueTx(tx);\n  console.log("TxID:", txID);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the above transaction, the ",(0,s.jsx)(n.code,{children:"outputs"})," parameter will be empty since we do not need\nto transfer any assets to the account. As you can see above we need to create\nanother type of output, for indicating the reward for delegation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const rewardOutputOwners = new SECPOwnerOutput(addresses.p, locktime, 2);\nconst rewardOwners = new ParseableOutput(rewardOutputOwners);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Call the function by adding the below function call."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"addDelegator();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Run this file using ",(0,s.jsx)(n.code,{children:"node examples/addDelegatorTx.js"}),", see the txID in the\noutput, and look for it in the Testnet explorer."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"multisig UTXOs 7",src:t(22411).A+"",width:"2925",height:"983"})})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},98236:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multisig-utxos-1-a60c23955fd177745fae878daf48ece8.png"},98871:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multisig-utxos-2-09c94f21882e66e8cb1e93a4bb4fb4ef.png"},14535:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multisig-utxos-3-1dcfa2e00c0271070bca23c25f655631.jpeg"},68350:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multisig-utxos-4-2061b42cd48e66e9fed85b3ccfb9ba9c.jpeg"},77189:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multisig-utxos-5-9158ed7a92a65909db11a023f3f2923e.jpeg"},98195:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multisig-utxos-6-dafc9ec96422f6d293a29471234d6dfc.png"},22411:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multisig-utxos-7-70ca75de9334a4abb31f3b2a6fd01848.jpeg"},43540:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(48318);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[4488],{87731:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=t(49214),s=t(43540);const a={tags:["Build","Virtual Machines"],description:"A Virtual Machine is a blueprint for a blockchain. VMs can define anything you want, but will generally define transactions that are executed and how blocks are created.",sidebar_label:"Introduction to VMs",pagination_label:"Introduction to Virtual Machines"},o="Introduction to Virtual Machines",r={id:"build/vm/intro",title:"Introduction to Virtual Machines",description:"A Virtual Machine is a blueprint for a blockchain. VMs can define anything you want, but will generally define transactions that are executed and how blocks are created.",source:"@site/docs/build/vm/intro.md",sourceDirName:"build/vm",slug:"/build/vm/intro",permalink:"/docs/build/vm/intro",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/build/vm/intro.md",tags:[{label:"Build",permalink:"/docs/tags/build"},{label:"Virtual Machines",permalink:"/docs/tags/virtual-machines"}],version:"current",frontMatter:{tags:["Build","Virtual Machines"],description:"A Virtual Machine is a blueprint for a blockchain. VMs can define anything you want, but will generally define transactions that are executed and how blocks are created.",sidebar_label:"Introduction to VMs",pagination_label:"Introduction to Virtual Machines"},sidebar:"build-vm",previous:{title:"Virtual Machines Quick Links",permalink:"/docs/build/vm/"},next:{title:"Build a Simple VM From Scratch",permalink:"/docs/build/vm/create/any-lang-vm"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Blocks and State",id:"blocks-and-state",level:2},{value:"Blockchain",id:"blockchain",level:2},{value:"Installing a VM",id:"installing-a-vm",level:2},{value:"API Handlers",id:"api-handlers",level:3},{value:"Instantiate a VM",id:"instantiate-a-vm",level:3},{value:"Initializing a VM to Create a Blockchain",id:"initializing-a-vm-to-create-a-blockchain",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"<code>block.ChainVM</code>",id:"blockchainvm",level:3},{value:"<code>common.VM</code>",id:"commonvm",level:3},{value:"<code>snowman.Block</code>",id:"snowmanblock",level:3},{value:"<code>choices.Decidable</code>",id:"choicesdecidable",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"introduction-to-virtual-machines",children:"Introduction to Virtual Machines"}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.a,{href:"/learn/lux/virtual-machines",children:"Virtual Machine (VM)"})," is a blueprint for a\nblockchain. Blockchains\nare instantiated from a VM, similar to how objects are instantiated from a class definition. VMs can\ndefine anything you want, but will generally define transactions that are executed and how blocks are\ncreated."]}),"\n",(0,i.jsx)(n.h2,{id:"blocks-and-state",children:"Blocks and State"}),"\n",(0,i.jsx)(n.p,{children:"Virtual Machines deal with blocks and state. The functionality provided by VMs is to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Define the representation of a blockchain's state"}),"\n",(0,i.jsx)(n.li,{children:"Represent the operations in that state"}),"\n",(0,i.jsx)(n.li,{children:"Apply the operations in that state"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each block in the blockchain contains a set of state transitions. Each block is applied in order\nfrom the blockchain's initial genesis block to its last accepted block to reach the latest state\nof the blockchain."}),"\n",(0,i.jsx)(n.h2,{id:"blockchain",children:"Blockchain"}),"\n",(0,i.jsxs)(n.p,{children:["A blockchain relies on two major components: The ",(0,i.jsx)(n.strong,{children:"Consensus Engine"})," and the ",(0,i.jsx)(n.strong,{children:"VM"}),". The VM defines\napplication specific behavior and how blocks are built and parsed to create the blockchain. All VMs\nrun on top of the Lux Consensus Engine, which allows nodes in the network to agree on the\nstate of the blockchain. Here's a quick example of how VMs interact with consensus:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"A node wants to update the blockchain's state"}),"\n",(0,i.jsx)(n.li,{children:"The node's VM will notify the consensus engine that it wants to update the state"}),"\n",(0,i.jsx)(n.li,{children:"The consensus engine will request the block from the VM"}),"\n",(0,i.jsxs)(n.li,{children:["The consensus engine will verify the returned block using the VM's implementation of ",(0,i.jsx)(n.code,{children:"Verify()"})]}),"\n",(0,i.jsxs)(n.li,{children:["The consensus engine will get the network to reach consensus on whether to accept or reject the newly\nverified block","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Every virtuous (well-behaved) node on the network will have the same preference for a particular\nblock"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Depending upon the consensus results, the engine will either accept or reject the block","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What happens when a block is accepted or rejected is specific to the implementation of the VM"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Luxd provides the consensus engine for every blockchain on the Lux Network. The consensus\nengine relies on the VM interface to handle building, parsing, and storing blocks as well as verifying\nand executing on behalf of the consensus engine."}),"\n",(0,i.jsx)(n.p,{children:"This decoupling between the application and consensus layer allows developers to build their\napplications quickly by implementing virtual machines, without having to worry about the consensus\nlayer managed by Lux which deals with how nodes agree on whether or not to accept a block."}),"\n",(0,i.jsx)(n.h2,{id:"installing-a-vm",children:"Installing a VM"}),"\n",(0,i.jsxs)(n.p,{children:["VMs are supplied as binaries to a node running ",(0,i.jsx)(n.code,{children:"Luxd"}),". These binaries must be named the VM's\nassigned ",(0,i.jsx)(n.strong,{children:"VMID"}),". A VMID is a 32-byte hash encoded in CB58 that is generated when you build your VM."]}),"\n",(0,i.jsxs)(n.p,{children:["In order to install a VM, its binary must be installed in the ",(0,i.jsx)(n.code,{children:"Luxd"})," plugin path. See\n",(0,i.jsx)(n.a,{href:"/docs/nodes/configure/luxd-config-flags#--plugin-dir-string",children:"here"})," for more details.\nMultiple VMs can be installed in this location."]}),"\n",(0,i.jsxs)(n.p,{children:["Each VM runs as a separate process from Luxd and communicates with ",(0,i.jsx)(n.code,{children:"Luxd"})," using gRPC\ncalls. This functionality is enabled by ",(0,i.jsx)(n.strong,{children:"RPCChainVM"}),", a special VM which wraps around other VM\nimplementations and bridges the VM and Luxd, establishing a standardized communication\nprotocol between them."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["During VM creation, handshake messages are exchanged via ",(0,i.jsx)(n.strong,{children:"RPCChainVM"})," between Luxd and the\nVM installation. Ensure matching ",(0,i.jsx)(n.strong,{children:"RPCChainVM"})," protocol versions to avoid\nerrors, by updating your VM or using a\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/Luxd/releases",children:"different version of Luxd"}),"."]}),(0,i.jsx)(n.p,{children:"Note that some VMs may not support the latest protocol version."})]}),"\n",(0,i.jsx)(n.h3,{id:"api-handlers",children:"API Handlers"}),"\n",(0,i.jsx)(n.p,{children:"Users can interact with a blockchain and its VM through handlers exposed by the VM's API."}),"\n",(0,i.jsx)(n.p,{children:"VMs expose two types of handlers to serve responses for incoming requests:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Blockchain Handlers"})," - Referred to as handlers, these expose APIs to interact with a blockchain\ninstantiated by a VM. The API endpoint will be different for each chain. The endpoint for a handler\nis ",(0,i.jsx)(n.code,{children:"/ext/bc/[chainID]"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"VM Handlers"})," - Referred to as static handlers, these expose APIs to interact with the VM\ndirectly. One example API would be to parse genesis data to instantiate a new blockchain. The endpoint\nfor a static handler is ",(0,i.jsx)(n.code,{children:"/ext/vm/[vmID]"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For any readers familiar with object-oriented programming, static and non-static handlers on a VM are\nanalogous to static and non-static methods on a class. Blockchain handlers can be thought of as methods\non an object, whereas VM handlers can be thought of as static methods on a class."}),"\n",(0,i.jsx)(n.h3,{id:"instantiate-a-vm",children:"Instantiate a VM"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"vm.Factory"})," interface is implemented to create new VM instances from which a blockchain can be\ninitialized. The factory's ",(0,i.jsx)(n.code,{children:"New"})," method shown below provides ",(0,i.jsx)(n.code,{children:"Luxd"})," with an instance of the\nVM. It's defined in the\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/timestampvm/blob/main/timestampvm/factory.go",children:(0,i.jsx)(n.code,{children:"factory.go"})})," file\nof the ",(0,i.jsx)(n.code,{children:"timestampvm"})," repository."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Returning a new VM instance from VM's factory\nfunc (f *Factory) New(*snow.Context) (interface{}, error) { return &vm.VM{}, nil }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"initializing-a-vm-to-create-a-blockchain",children:"Initializing a VM to Create a Blockchain"}),"\n",(0,i.jsxs)(n.p,{children:["Before a VM can run, Luxd will initialize it by invoking its ",(0,i.jsx)(n.code,{children:"Initialize"})," method. Here, the\nVM will bootstrap itself and sets up anything it requires before it starts running."]}),"\n",(0,i.jsx)(n.p,{children:"This might involve setting up its database, mempool, genesis state, or anything else the VM requires\nto run."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"if err := vm.Initialize(\n    ctx.Context,\n    vmDBManager,\n    genesisData,\n    chainConfig.Upgrade,\n    chainConfig.Config,\n    msgChan,\n    fxs,\n    sender,\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can refer to the\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/timestampvm/blob/main/timestampvm/vm.go#L75",children:"implementation"})," of\n",(0,i.jsx)(n.code,{children:"vm.initialize"})," in the TimestampVM repository."]}),"\n",(0,i.jsx)(n.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,i.jsx)(n.p,{children:"Every VM should implement the following interfaces:"}),"\n",(0,i.jsx)(n.h3,{id:"blockchainvm",children:(0,i.jsx)(n.code,{children:"block.ChainVM"})}),"\n",(0,i.jsxs)(n.p,{children:["To reach a consensus on linear blockchains, Lux uses the Snowman consensus engine. To be\ncompatible with Snowman, a VM must implement the ",(0,i.jsx)(n.code,{children:"block.ChainVM"})," interface."]}),"\n",(0,i.jsxs)(n.p,{children:["For more information, see ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/engine/snowman/block/vm.go",children:"here"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="/snow/engine/snowman/block/vm.go"',children:"// ChainVM defines the required functionality of a Snowman VM.\n//\n// A Snowman VM is responsible for defining the representation of the state,\n// the representation of operations in that state, the application of operations\n// on that state, and the creation of the operations. Consensus will decide on\n// if the operation is executed and the order operations are executed.\n//\n// For example, suppose we have a VM that tracks an increasing number that\n// is agreed upon by the network.\n// The state is a single number.\n// The operation is setting the number to a new, larger value.\n// Applying the operation will save to the database the new value.\n// The VM can attempt to issue a new number, of larger value, at any time.\n// Consensus will ensure the network agrees on the number at every block height.\ntype ChainVM interface {\n\tcommon.VM\n\tGetter\n\tParser\n\n\t// Attempt to create a new block from data contained in the VM.\n\t//\n\t// If the VM doesn't want to issue a new block, an error should be\n\t// returned.\n\tBuildBlock() (snowman.Block, error)\n\n\t// Notify the VM of the currently preferred block.\n\t//\n\t// This should always be a block that has no children known to consensus.\n\tSetPreference(ids.ID) error\n\n\t// LastAccepted returns the ID of the last accepted block.\n\t//\n\t// If no blocks have been accepted by consensus yet, it is assumed there is\n\t// a definitionally accepted block, the Genesis block, that will be\n\t// returned.\n\tLastAccepted() (ids.ID, error)\n}\n\n// Getter defines the functionality for fetching a block by its ID.\ntype Getter interface {\n\t// Attempt to load a block.\n\t//\n\t// If the block does not exist, an error should be returned.\n\t//\n\tGetBlock(ids.ID) (snowman.Block, error)\n}\n\n// Parser defines the functionality for fetching a block by its bytes.\ntype Parser interface {\n\t// Attempt to create a block from a stream of bytes.\n\t//\n\t// The block should be represented by the full byte array, without extra\n\t// bytes.\n\tParseBlock([]byte) (snowman.Block, error)\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"commonvm",children:(0,i.jsx)(n.code,{children:"common.VM"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"common.VM"})," is a type that every ",(0,i.jsx)(n.code,{children:"VM"})," must implement."]}),"\n",(0,i.jsxs)(n.p,{children:["For more information, you can see the full file ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/engine/common/vm.go",children:"here"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="/snow/engine/common/vm.go"',children:"// VM describes the interface that all consensus VMs must implement\ntype VM interface {\n    // Contains handlers for VM-to-VM specific messages\n\tAppHandler\n\n\t// Returns nil if the VM is healthy.\n\t// Periodically called and reported via the node's Health API.\n\thealth.Checkable\n\n\t// Connector represents a handler that is called on connection connect/disconnect\n\tvalidators.Connector\n\n\t// Initialize this VM.\n\t// [ctx]: Metadata about this VM.\n\t//     [ctx.networkID]: The ID of the network this VM's chain is running on.\n\t//     [ctx.chainID]: The unique ID of the chain this VM is running on.\n\t//     [ctx.Log]: Used to log messages\n\t//     [ctx.NodeID]: The unique staker ID of this node.\n\t//     [ctx.Lock]: A Read/Write lock shared by this VM and the consensus\n\t//                 engine that manages this VM. The write lock is held\n\t//                 whenever code in the consensus engine calls the VM.\n\t// [dbManager]: The manager of the database this VM will persist data to.\n\t// [genesisBytes]: The byte-encoding of the genesis information of this\n\t//                 VM. The VM uses it to initialize its state. For\n\t//                 example, if this VM were an account-based payments\n\t//                 system, `genesisBytes` would probably contain a genesis\n\t//                 transaction that gives coins to some accounts, and this\n\t//                 transaction would be in the genesis block.\n\t// [toEngine]: The channel used to send messages to the consensus engine.\n\t// [fxs]: Feature extensions that attach to this VM.\n\tInitialize(\n\t\tctx *snow.Context,\n\t\tdbManager manager.Manager,\n\t\tgenesisBytes []byte,\n\t\tupgradeBytes []byte,\n\t\tconfigBytes []byte,\n\t\ttoEngine chan<- Message,\n\t\tfxs []*Fx,\n\t\tappSender AppSender,\n\t) error\n\n\t// Bootstrapping is called when the node is starting to bootstrap this chain.\n\tBootstrapping() error\n\n\t// Bootstrapped is called when the node is done bootstrapping this chain.\n\tBootstrapped() error\n\n\t// Shutdown is called when the node is shutting down.\n\tShutdown() error\n\n\t// Version returns the version of the VM this node is running.\n\tVersion() (string, error)\n\n\t// Creates the HTTP handlers for custom VM network calls.\n\t//\n\t// This exposes handlers that the outside world can use to communicate with\n\t// a static reference to the VM. Each handler has the path:\n\t// [Address of node]/ext/VM/[VM ID]/[extension]\n\t//\n\t// Returns a mapping from [extension]s to HTTP handlers.\n\t//\n\t// Each extension can specify how locking is managed for convenience.\n\t//\n\t// For example, it might make sense to have an extension for creating\n\t// genesis bytes this VM can interpret.\n\tCreateStaticHandlers() (map[string]*HTTPHandler, error)\n\n\t// Creates the HTTP handlers for custom chain network calls.\n\t//\n\t// This exposes handlers that the outside world can use to communicate with\n\t// the chain. Each handler has the path:\n\t// [Address of node]/ext/bc/[chain ID]/[extension]\n\t//\n\t// Returns a mapping from [extension]s to HTTP handlers.\n\t//\n\t// Each extension can specify how locking is managed for convenience.\n\t//\n\t// For example, if this VM implements an account-based payments system,\n\t// it have an extension called `accounts`, where clients could get\n\t// information about their accounts.\n\tCreateHandlers() (map[string]*HTTPHandler, error)\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"snowmanblock",children:(0,i.jsx)(n.code,{children:"snowman.Block"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"snowman.Block"})," interface It define the functionality a block must implement to be a block in a\nlinear Snowman chain."]}),"\n",(0,i.jsxs)(n.p,{children:["For more information, you can see the full file ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/consensus/snowman/block.go",children:"here"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="/snow/consensus/snowman/block.go"',children:"// Block is a possible decision that dictates the next canonical block.\n//\n// Blocks are guaranteed to be Verified, Accepted, and Rejected in topological\n// order. Specifically, if Verify is called, then the parent has already been\n// verified. If Accept is called, then the parent has already been accepted. If\n// Reject is called, the parent has already been accepted or rejected.\n//\n// If the status of the block is Unknown, ID is assumed to be able to be called.\n// If the status of the block is Accepted or Rejected; Parent, Verify, Accept,\n// and Reject will never be called.\ntype Block interface {\n    choices.Decidable\n\n    // Parent returns the ID of this block's parent.\n    Parent() ids.ID\n\n    // Verify that the state transition this block would make if accepted is\n    // valid. If the state transition is invalid, a non-nil error should be\n    // returned.\n    //\n    // It is guaranteed that the Parent has been successfully verified.\n    Verify() error\n\n    // Bytes returns the binary representation of this block.\n    //\n    // This is used for sending blocks to peers. The bytes should be able to be\n    // parsed into the same block on another node.\n    Bytes() []byte\n\n    // Height returns the height of this block in the chain.\n    Height() uint64\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"choicesdecidable",children:(0,i.jsx)(n.code,{children:"choices.Decidable"})}),"\n",(0,i.jsx)(n.p,{children:"This interface is a superset of every decidable object, such as transactions, blocks, and vertices."}),"\n",(0,i.jsxs)(n.p,{children:["For more information, you can see the full file ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/luxd/blob/master/snow/choices/decidable.go",children:"here"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="/snow/choices/decidable.go"',children:"// Decidable represents element that can be decided.\n//\n// Decidable objects are typically thought of as either transactions, blocks, or\n// vertices.\ntype Decidable interface {\n\t// ID returns a unique ID for this element.\n\t//\n\t// Typically, this is implemented by using a cryptographic hash of a\n\t// binary representation of this element. An element should return the same\n\t// IDs upon repeated calls.\n\tID() ids.ID\n\n\t// Accept this element.\n\t//\n\t// This element will be accepted by every correct node in the network.\n\tAccept() error\n\n\t// Reject this element.\n\t//\n\t// This element will not be accepted by any correct node in the network.\n\tReject() error\n\n\t// Status returns this element's current status.\n\t//\n\t// If Accept has been called on an element with this ID, Accepted should be\n\t// returned. Similarly, if Reject has been called on an element with this\n\t// ID, Rejected should be returned. If the contents of this element are\n\t// unknown, then Unknown should be returned. Otherwise, Processing should be\n\t// returned.\n\tStatus() Status\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},43540:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(48318);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[9255],{24641:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=n(49214),i=n(43540);const r={tags:["Build","Virtual Machines"],description:"Learn how to build a simple virtual machine on Lux using Golang.",sidebar_label:"Simple Golang VM",pagination_label:"Build a Simple Golang VM",sidebar_position:1},a="How to Build a Simple Golang VM",o={id:"build/vm/create/golang-vm-simple",title:"How to Build a Simple Golang VM",description:"Learn how to build a simple virtual machine on Lux using Golang.",source:"@site/docs/build/vm/create/golang-vm-simple.md",sourceDirName:"build/vm/create",slug:"/build/vm/create/golang-vm-simple",permalink:"/docs/build/vm/create/golang-vm-simple",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/build/vm/create/golang-vm-simple.md",tags:[{label:"Build",permalink:"/docs/tags/build"},{label:"Virtual Machines",permalink:"/docs/tags/virtual-machines"}],version:"current",sidebarPosition:1,frontMatter:{tags:["Build","Virtual Machines"],description:"Learn how to build a simple virtual machine on Lux using Golang.",sidebar_label:"Simple Golang VM",pagination_label:"Build a Simple Golang VM",sidebar_position:1},sidebar:"build-vm",previous:{title:"Build a Simple VM From Scratch",permalink:"/docs/build/vm/create/any-lang-vm"},next:{title:"Build a Complex Golang VM",permalink:"/docs/build/vm/create/golang-vm-complex"}},l={},c=[{value:"TimestampVM Implementation",id:"timestampvm-implementation",level:2},{value:"Codec",id:"codec",level:3},{value:"State",id:"state",level:3},{value:"Block State",id:"block-state",level:4},{value:"Block",id:"block",level:3},{value:"Verify",id:"verify",level:4},{value:"Accept",id:"accept",level:4},{value:"Reject",id:"reject",level:4},{value:"Block Field Methods",id:"block-field-methods",level:4},{value:"Helper Functions",id:"helper-functions",level:4},{value:"Virtual Machine",id:"virtual-machine",level:3},{value:"Initialize",id:"initialize",level:4},{value:"<code>initGenesis</code>",id:"initgenesis",level:5},{value:"CreateHandlers",id:"createhandlers",level:4},{value:"CreateStaticHandlers",id:"createstatichandlers",level:4},{value:"BuildBock",id:"buildbock",level:4},{value:"NotifyBlockReady",id:"notifyblockready",level:4},{value:"GetBlock",id:"getblock",level:4},{value:"<code>proposeBlock</code>",id:"proposeblock",level:4},{value:"ParseBlock",id:"parseblock",level:4},{value:"NewBlock",id:"newblock",level:4},{value:"SetPreference",id:"setpreference",level:4},{value:"Other Functions",id:"other-functions",level:4},{value:"Factory",id:"factory",level:3},{value:"Static API",id:"static-api",level:3},{value:"Encode",id:"encode",level:4},{value:"Decode",id:"decode",level:4},{value:"API",id:"api",level:3},{value:"<code>timestampvm.getBlock</code>",id:"timestampvmgetblock",level:4},{value:"<code>getBlock</code> Signature",id:"getblock-signature",level:5},{value:"<code>getBlock</code> Example Call",id:"getblock-example-call",level:5},{value:"<code>getBlock</code> Example Response",id:"getblock-example-response",level:5},{value:"<code>getBlock</code> Implementation",id:"getblock-implementation",level:5},{value:"<code>timestampvm.proposeBlock</code>",id:"timestampvmproposeblock",level:4},{value:"<code>proposeBlock</code> Signature",id:"proposeblock-signature",level:5},{value:"<code>proposeBlock</code> Example Call",id:"proposeblock-example-call",level:5},{value:"<code>proposeBlock</code> Example Response",id:"proposeblock-example-response",level:6},{value:"<code>proposeBlock</code> Implementation",id:"proposeblock-implementation",level:5},{value:"Plugin",id:"plugin",level:3},{value:"Executable Binary",id:"executable-binary",level:3},{value:"VM Aliases",id:"vm-aliases",level:3},{value:"Installing a VM",id:"installing-a-vm",level:3},{value:"Node Is Not Running",id:"node-is-not-running",level:4},{value:"Node Is Already Running",id:"node-is-already-running",level:4},{value:"Wrapping Up",id:"wrapping-up",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"how-to-build-a-simple-golang-vm",children:"How to Build a Simple Golang VM"}),"\n",(0,s.jsxs)(t.p,{children:["In this tutorial, we\u2019ll create a very simple VM called the\n",(0,s.jsx)(t.a,{href:"https://github.com/luxfi/timestampvm/tree/v1.2.1",children:"TimestampVM"}),". Each block in the TimestampVM's\nblockchain contains a strictly increasing timestamp when the block was created and a 32-byte payload\nof data."]}),"\n",(0,s.jsx)(t.p,{children:"Such a server is useful because it can be used to prove a piece of data existed at the time the\nblock was created. Suppose you have a book manuscript, and you want to be able to prove in the\nfuture that the manuscript exists today. You can add a block to the blockchain where the block\u2019s\npayload is a hash of your manuscript. In the future, you can prove that the manuscript existed today\nby showing that the block has the hash of your manuscript in its payload (this follows from the fact\nthat finding the pre-image of a hash is impossible)."}),"\n",(0,s.jsx)(t.h2,{id:"timestampvm-implementation",children:"TimestampVM Implementation"}),"\n",(0,s.jsx)(t.p,{children:"Now we know the interface our VM must implement and the libraries we can use to build a VM."}),"\n",(0,s.jsxs)(t.p,{children:["Let\u2019s write our VM, which implements ",(0,s.jsx)(t.code,{children:"block.ChainVM"})," and whose blocks implement ",(0,s.jsx)(t.code,{children:"snowman.Block"}),". You\ncan also follow the code in the ",(0,s.jsx)(t.a,{href:"https://github.com/luxfi/timestampvm/tree/main",children:"TimestampVM\nrepository"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"codec",children:"Codec"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Codec"})," is required to encode/decode the block into byte representation. TimestampVM uses the\ndefault codec and manager."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/codec.go"',children:"const (\n\t// CodecVersion is the current default codec version\n\tCodecVersion = 0\n)\n\n// Codecs do serialization and deserialization\nvar (\n\tCodec codec.Manager\n)\n\nfunc init() {\n\t// Create default codec and manager\n\tc := linearcodec.NewDefault()\n\tCodec = codec.NewDefaultManager()\n\n\t// Register codec to manager with CodecVersion\n\tif err := Codec.RegisterCodec(CodecVersion, c); err != nil {\n\t\tpanic(err)\n\t}\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"state",children:"State"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"State"})," interface defines the database layer and connections. Each VM should define their own\ndatabase methods. ",(0,s.jsx)(t.code,{children:"State"})," embeds the ",(0,s.jsx)(t.code,{children:"BlockState"})," which defines block-related state operations."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/state.go"',children:'var (\n\t// These are prefixes for db keys.\n\t// It\'s important to set different prefixes for each separate database objects.\n\tsingletonStatePrefix = []byte("singleton")\n\tblockStatePrefix     = []byte("block")\n\n\t_ State = &state{}\n)\n\n// State is a wrapper around lux.SingleTonState and BlockState\n// State also exposes a few methods needed for managing database commits and close.\ntype State interface {\n\t// SingletonState is defined in luxd,\n\t// it is used to understand if db is initialized already.\n\tlux.SingletonState\n\tBlockState\n\n\tCommit() error\n\tClose() error\n}\n\ntype state struct {\n\tlux.SingletonState\n\tBlockState\n\n\tbaseDB *versiondb.Database\n}\n\nfunc NewState(db database.Database, vm *VM) State {\n\t// create a new baseDB\n\tbaseDB := versiondb.New(db)\n\n\t// create a prefixed "blockDB" from baseDB\n\tblockDB := prefixdb.New(blockStatePrefix, baseDB)\n\t// create a prefixed "singletonDB" from baseDB\n\tsingletonDB := prefixdb.New(singletonStatePrefix, baseDB)\n\n\t// return state with created sub state components\n\treturn &state{\n\t\tBlockState:     NewBlockState(blockDB, vm),\n\t\tSingletonState: lux.NewSingletonState(singletonDB),\n\t\tbaseDB:         baseDB,\n\t}\n}\n\n// Commit commits pending operations to baseDB\nfunc (s *state) Commit() error {\n\treturn s.baseDB.Commit()\n}\n\n// Close closes the underlying base database\nfunc (s *state) Close() error {\n\treturn s.baseDB.Close()\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"block-state",children:"Block State"}),"\n",(0,s.jsx)(t.p,{children:"This interface and implementation provides storage functions to VM to store and retrieve blocks."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/block_state.go"',children:'const (\n\tlastAcceptedByte byte = iota\n)\n\nconst (\n\t// maximum block capacity of the cache\n\tblockCacheSize = 8192\n)\n\n// persists lastAccepted block IDs with this key\nvar lastAcceptedKey = []byte{lastAcceptedByte}\n\nvar _ BlockState = &blockState{}\n\n// BlockState defines methods to manage state with Blocks and LastAcceptedIDs.\ntype BlockState interface {\n\tGetBlock(blkID ids.ID) (*Block, error)\n\tPutBlock(blk *Block) error\n\n\tGetLastAccepted() (ids.ID, error)\n\tSetLastAccepted(ids.ID) error\n}\n\n// blockState implements BlocksState interface with database and cache.\ntype blockState struct {\n\t// cache to store blocks\n\tblkCache cache.Cacher\n\t// block database\n\tblockDB      database.Database\n\tlastAccepted ids.ID\n\n\t// vm reference\n\tvm *VM\n}\n\n// blkWrapper wraps the actual blk bytes and status to persist them together\ntype blkWrapper struct {\n\tBlk    []byte         `serialize:"true"`\n\tStatus choices.Status `serialize:"true"`\n}\n\n// NewBlockState returns BlockState with a new cache and given db\nfunc NewBlockState(db database.Database, vm *VM) BlockState {\n\treturn &blockState{\n\t\tblkCache: &cache.LRU{Size: blockCacheSize},\n\t\tblockDB:  db,\n\t\tvm:       vm,\n\t}\n}\n\n// GetBlock gets Block from either cache or database\nfunc (s *blockState) GetBlock(blkID ids.ID) (*Block, error) {\n\t// Check if cache has this blkID\n\tif blkIntf, cached := s.blkCache.Get(blkID); cached {\n\t\t// there is a key but value is nil, so return an error\n\t\tif blkIntf == nil {\n\t\t\treturn nil, database.ErrNotFound\n\t\t}\n\t\t// We found it return the block in cache\n\t\treturn blkIntf.(*Block), nil\n\t}\n\n\t// get block bytes from db with the blkID key\n\twrappedBytes, err := s.blockDB.Get(blkID[:])\n\tif err != nil {\n\t\t// we could not find it in the db, let\'s cache this blkID with nil value\n\t\t// so next time we try to fetch the same key we can return error\n\t\t// without hitting the database\n\t\tif err == database.ErrNotFound {\n\t\t\ts.blkCache.Put(blkID, nil)\n\t\t}\n\t\t// could not find the block, return error\n\t\treturn nil, err\n\t}\n\n\t// first decode/unmarshal the block wrapper so we can have status and block bytes\n\tblkw := blkWrapper{}\n\tif _, err := Codec.Unmarshal(wrappedBytes, &blkw); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// now decode/unmarshal the actual block bytes to block\n\tblk := &Block{}\n\tif _, err := Codec.Unmarshal(blkw.Blk, blk); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// initialize block with block bytes, status and vm\n\tblk.Initialize(blkw.Blk, blkw.Status, s.vm)\n\n\t// put block into cache\n\ts.blkCache.Put(blkID, blk)\n\n\treturn blk, nil\n}\n\n// PutBlock puts block into both database and cache\nfunc (s *blockState) PutBlock(blk *Block) error {\n\t// create block wrapper with block bytes and status\n\tblkw := blkWrapper{\n\t\tBlk:    blk.Bytes(),\n\t\tStatus: blk.Status(),\n\t}\n\n\t// encode block wrapper to its byte representation\n\twrappedBytes, err := Codec.Marshal(CodecVersion, &blkw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblkID := blk.ID()\n\t// put actual block to cache, so we can directly fetch it from cache\n\ts.blkCache.Put(blkID, blk)\n\n\t// put wrapped block bytes into database\n\treturn s.blockDB.Put(blkID[:], wrappedBytes)\n}\n\n// DeleteBlock deletes block from both cache and database\nfunc (s *blockState) DeleteBlock(blkID ids.ID) error {\n\ts.blkCache.Put(blkID, nil)\n\treturn s.blockDB.Delete(blkID[:])\n}\n\n// GetLastAccepted returns last accepted block ID\nfunc (s *blockState) GetLastAccepted() (ids.ID, error) {\n\t// check if we already have lastAccepted ID in state memory\n\tif s.lastAccepted != ids.Empty {\n\t\treturn s.lastAccepted, nil\n\t}\n\n\t// get lastAccepted bytes from database with the fixed lastAcceptedKey\n\tlastAcceptedBytes, err := s.blockDB.Get(lastAcceptedKey)\n\tif err != nil {\n\t\treturn ids.ID{}, err\n\t}\n\t// parse bytes to ID\n\tlastAccepted, err := ids.ToID(lastAcceptedBytes)\n\tif err != nil {\n\t\treturn ids.ID{}, err\n\t}\n\t// put lastAccepted ID into memory\n\ts.lastAccepted = lastAccepted\n\treturn lastAccepted, nil\n}\n\n// SetLastAccepted persists lastAccepted ID into both cache and database\nfunc (s *blockState) SetLastAccepted(lastAccepted ids.ID) error {\n\t// if the ID in memory and the given memory are same don\'t do anything\n\tif s.lastAccepted == lastAccepted {\n\t\treturn nil\n\t}\n\t// put lastAccepted ID to memory\n\ts.lastAccepted = lastAccepted\n\t// persist lastAccepted ID to database with fixed lastAcceptedKey\n\treturn s.blockDB.Put(lastAcceptedKey, lastAccepted[:])\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"block",children:"Block"}),"\n",(0,s.jsx)(t.p,{children:"Let\u2019s look at our block implementation."}),"\n",(0,s.jsx)(t.p,{children:"The type declaration is:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/block.go"',children:'// Block is a block on the chain.\n// Each block contains:\n// 1) ParentID\n// 2) Height\n// 3) Timestamp\n// 4) A piece of data (a string)\ntype Block struct {\n\tPrntID ids.ID        `serialize:"true" json:"parentID"`  // parent\'s ID\n\tHght   uint64        `serialize:"true" json:"height"`    // This block\'s height. The genesis block is at height 0.\n\tTmstmp int64         `serialize:"true" json:"timestamp"` // Time this block was proposed at\n\tDt     [dataLen]byte `serialize:"true" json:"data"`      // Arbitrary data\n\n\tid     ids.ID         // hold this block\'s ID\n\tbytes  []byte         // this block\'s encoded bytes\n\tstatus choices.Status // block\'s status\n\tvm     *VM            // the underlying VM reference, mostly used for state\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:'serialize:"true"'})," tag indicates that the field should be included in the byte representation of\nthe block used when persisting the block or sending it to other nodes."]}),"\n",(0,s.jsx)(t.h4,{id:"verify",children:"Verify"}),"\n",(0,s.jsxs)(t.p,{children:["This method verifies that a block is valid and stores it in the memory. It is important to store the\nverified block in the memory and return them in the ",(0,s.jsx)(t.code,{children:"vm.GetBlock"})," method."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/block.go"',children:"// Verify returns nil iff this block is valid.\n// To be valid, it must be that:\n// b.parent.Timestamp < b.Timestamp <= [local time] + 1 hour\nfunc (b *Block) Verify() error {\n\t// Get [b]'s parent\n\tparentID := b.Parent()\n\tparent, err := b.vm.getBlock(parentID)\n\tif err != nil {\n\t\treturn errDatabaseGet\n\t}\n\n\t// Ensure [b]'s height comes right after its parent's height\n\tif expectedHeight := parent.Height() + 1; expectedHeight != b.Hght {\n\t\treturn fmt.Errorf(\n\t\t\t\"expected block to have height %d, but found %d\",\n\t\t\texpectedHeight,\n\t\t\tb.Hght,\n\t\t)\n\t}\n\n\t// Ensure [b]'s timestamp is after its parent's timestamp.\n\tif b.Timestamp().Unix() < parent.Timestamp().Unix() {\n\t\treturn errTimestampTooEarly\n\t}\n\n\t// Ensure [b]'s timestamp is not more than an hour\n\t// ahead of this node's time\n\tif b.Timestamp().Unix() >= time.Now().Add(time.Hour).Unix() {\n\t\treturn errTimestampTooLate\n\t}\n\n\t// Put that block to verified blocks in memory\n\tb.vm.verifiedBlocks[b.ID()] = b\n\n\treturn nil\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"accept",children:"Accept"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Accept"})," is called by the consensus to indicate this block is accepted."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/block.go"',children:"// Accept sets this block's status to Accepted and sets lastAccepted to this\n// block's ID and saves this info to b.vm.DB\nfunc (b *Block) Accept() error {\n\tb.SetStatus(choices.Accepted) // Change state of this block\n\tblkID := b.ID()\n\n\t// Persist data\n\tif err := b.vm.state.PutBlock(b); err != nil {\n\t\treturn err\n\t}\n\n\t// Set last accepted ID to this block ID\n\tif err := b.vm.state.SetLastAccepted(blkID); err != nil {\n\t\treturn err\n\t}\n\n\t// Delete this block from verified blocks as it's accepted\n\tdelete(b.vm.verifiedBlocks, b.ID())\n\n\t// Commit changes to database\n\treturn b.vm.state.Commit()\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"reject",children:"Reject"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Reject"})," is called by the consensus to indicate this block is rejected."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/block.go"',children:"// Reject sets this block's status to Rejected and saves the status in state\n// Recall that b.vm.DB.Commit() must be called to persist to the DB\nfunc (b *Block) Reject() error {\n\tb.SetStatus(choices.Rejected) // Change state of this block\n\tif err := b.vm.state.PutBlock(b); err != nil {\n\t\treturn err\n\t}\n\t// Delete this block from verified blocks as it's rejected\n\tdelete(b.vm.verifiedBlocks, b.ID())\n\t// Commit changes to database\n\treturn b.vm.state.Commit()\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"block-field-methods",children:"Block Field Methods"}),"\n",(0,s.jsxs)(t.p,{children:["These methods are required by the ",(0,s.jsx)(t.code,{children:"snowman.Block"})," interface."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/block.go"',children:"// ID returns the ID of this block\nfunc (b *Block) ID() ids.ID { return b.id }\n\n// ParentID returns [b]'s parent's ID\nfunc (b *Block) Parent() ids.ID { return b.PrntID }\n\n// Height returns this block's height. The genesis block has height 0.\nfunc (b *Block) Height() uint64 { return b.Hght }\n\n// Timestamp returns this block's time. The genesis block has time 0.\nfunc (b *Block) Timestamp() time.Time { return time.Unix(b.Tmstmp, 0) }\n\n// Status returns the status of this block\nfunc (b *Block) Status() choices.Status { return b.status }\n\n// Bytes returns the byte repr. of this block\nfunc (b *Block) Bytes() []byte { return b.bytes }\n"})}),"\n",(0,s.jsx)(t.h4,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,s.jsx)(t.p,{children:"These methods are convenience methods for blocks, they're not a part of the block interface."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:"// Initialize sets [b.bytes] to [bytes], [b.id] to hash([b.bytes]),\n// [b.status] to [status] and [b.vm] to [vm]\nfunc (b *Block) Initialize(bytes []byte, status choices.Status, vm *VM) {\n\tb.bytes = bytes\n\tb.id = hashing.ComputeHash256Array(b.bytes)\n\tb.status = status\n\tb.vm = vm\n}\n\n// SetStatus sets the status of this block\nfunc (b *Block) SetStatus(status choices.Status) { b.status = status }\n"})}),"\n",(0,s.jsx)(t.h3,{id:"virtual-machine",children:"Virtual Machine"}),"\n",(0,s.jsxs)(t.p,{children:["Now, let\u2019s look at our timestamp VM implementation, which implements the ",(0,s.jsx)(t.code,{children:"block.ChainVM"})," interface."]}),"\n",(0,s.jsx)(t.p,{children:"The declaration is:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:"// This Virtual Machine defines a blockchain that acts as a timestamp server\n// Each block contains data (a payload) and the timestamp when it was created\n\nconst (\n  dataLen = 32\n\tName    = \"timestampvm\"\n)\n\n// VM implements the snowman.VM interface\n// Each block in this chain contains a Unix timestamp\n// and a piece of data (a string)\ntype VM struct {\n\t// The context of this vm\n\tctx       *snow.Context\n\tdbManager manager.Manager\n\n\t// State of this VM\n\tstate State\n\n\t// ID of the preferred block\n\tpreferred ids.ID\n\n\t// channel to send messages to the consensus engine\n\ttoEngine chan<- common.Message\n\n\t// Proposed pieces of data that haven't been put into a block and proposed yet\n\tmempool [][dataLen]byte\n\n\t// Block ID --\x3e Block\n\t// Each element is a block that passed verification but\n\t// hasn't yet been accepted/rejected\n\tverifiedBlocks map[ids.ID]*Block\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"initialize",children:"Initialize"}),"\n",(0,s.jsx)(t.p,{children:"This method is called when a new instance of VM is initialized. Genesis block is created under this method."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:'// Initialize this vm\n// [ctx] is this vm\'s context\n// [dbManager] is the manager of this vm\'s database\n// [toEngine] is used to notify the consensus engine that new blocks are\n//   ready to be added to consensus\n// The data in the genesis block is [genesisData]\nfunc (vm *VM) Initialize(\n\tctx *snow.Context,\n\tdbManager manager.Manager,\n\tgenesisData []byte,\n\tupgradeData []byte,\n\tconfigData []byte,\n\ttoEngine chan<- common.Message,\n\t_ []*common.Fx,\n\t_ common.AppSender,\n) error {\n\tversion, err := vm.Version()\n\tif err != nil {\n\t\tlog.Error("error initializing Timestamp VM: %v", err)\n\t\treturn err\n\t}\n\tlog.Info("Initializing Timestamp VM", "Version", version)\n\n\tvm.dbManager = dbManager\n\tvm.ctx = ctx\n\tvm.toEngine = toEngine\n\tvm.verifiedBlocks = make(map[ids.ID]*Block)\n\n\t// Create new state\n\tvm.state = NewState(vm.dbManager.Current().Database, vm)\n\n\t// Initialize genesis\n\tif err := vm.initGenesis(genesisData); err != nil {\n\t\treturn err\n\t}\n\n\t// Get last accepted\n\tlastAccepted, err := vm.state.GetLastAccepted()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx.Log.Info("initializing last accepted block as %s", lastAccepted)\n\n\t// Build off the most recently accepted block\n\treturn vm.SetPreference(lastAccepted)\n}\n'})}),"\n",(0,s.jsx)(t.h5,{id:"initgenesis",children:(0,s.jsx)(t.code,{children:"initGenesis"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"initGenesis"})," is a helper method which initializes the genesis block from given bytes and puts into\nthe state."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:'// Initializes Genesis if required\nfunc (vm *VM) initGenesis(genesisData []byte) error {\n\tstateInitialized, err := vm.state.IsInitialized()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// if state is already initialized, skip init genesis.\n\tif stateInitialized {\n\t\treturn nil\n\t}\n\n\tif len(genesisData) > dataLen {\n\t\treturn errBadGenesisBytes\n\t}\n\n\t// genesisData is a byte slice but each block contains an byte array\n\t// Take the first [dataLen] bytes from genesisData and put them in an array\n\tvar genesisDataArr [dataLen]byte\n\tcopy(genesisDataArr[:], genesisData)\n\n\t// Create the genesis block\n\t// Timestamp of genesis block is 0. It has no parent.\n\tgenesisBlock, err := vm.NewBlock(ids.Empty, 0, genesisDataArr, time.Unix(0, 0))\n\tif err != nil {\n\t\tlog.Error("error while creating genesis block: %v", err)\n\t\treturn err\n\t}\n\n\t// Put genesis block to state\n\tif err := vm.state.PutBlock(genesisBlock); err != nil {\n\t\tlog.Error("error while saving genesis block: %v", err)\n\t\treturn err\n\t}\n\n\t// Accept the genesis block\n\t// Sets [vm.lastAccepted] and [vm.preferred]\n\tif err := genesisBlock.Accept(); err != nil {\n\t\treturn fmt.Errorf("error accepting genesis block: %w", err)\n\t}\n\n\t// Mark this vm\'s state as initialized, so we can skip initGenesis in further restarts\n\tif err := vm.state.SetInitialized(); err != nil {\n\t\treturn fmt.Errorf("error while setting db to initialized: %w", err)\n\t}\n\n\t// Flush VM\'s database to underlying db\n\treturn vm.state.Commit()\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"createhandlers",children:"CreateHandlers"}),"\n",(0,s.jsxs)(t.p,{children:["Registered handlers defined in ",(0,s.jsx)(t.code,{children:"Service"}),". See ",(0,s.jsx)(t.a,{href:"/docs/build/vm/create/golang-vm-simple#api",children:"below"})," for\nmore on APIs."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:'// CreateHandlers returns a map where:\n// Keys: The path extension for this blockchain\'s API (empty in this case)\n// Values: The handler for the API\n// In this case, our blockchain has only one API, which we name timestamp,\n// and it has no path extension, so the API endpoint:\n// [Node IP]/ext/bc/[this blockchain\'s ID]\n// See API section in documentation for more information\nfunc (vm *VM) CreateHandlers() (map[string]*common.HTTPHandler, error) {\n\tserver := rpc.NewServer()\n\tserver.RegisterCodec(json.NewCodec(), "application/json")\n\tserver.RegisterCodec(json.NewCodec(), "application/json;charset=UTF-8")\n    // Name is "timestampvm"\n\tif err := server.RegisterService(&Service{vm: vm}, Name); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn map[string]*common.HTTPHandler{\n\t\t"": {\n\t\t\tHandler: server,\n\t\t},\n\t}, nil\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"createstatichandlers",children:"CreateStaticHandlers"}),"\n",(0,s.jsxs)(t.p,{children:["Registers static handlers defined in ",(0,s.jsx)(t.code,{children:"StaticService"}),". See\n",(0,s.jsx)(t.a,{href:"/docs/build/vm/create/golang-vm-simple#static-api",children:"below"})," for more on static APIs."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:'// CreateStaticHandlers returns a map where:\n// Keys: The path extension for this VM\'s static API\n// Values: The handler for that static API\nfunc (vm *VM) CreateStaticHandlers() (map[string]*common.HTTPHandler, error) {\n\tserver := rpc.NewServer()\n\tserver.RegisterCodec(json.NewCodec(), "application/json")\n\tserver.RegisterCodec(json.NewCodec(), "application/json;charset=UTF-8")\n\tif err := server.RegisterService(&StaticService{}, Name); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn map[string]*common.HTTPHandler{\n\t\t"": {\n\t\t\tLockOptions: common.NoLock,\n\t\t\tHandler:     server,\n\t\t},\n\t}, nil\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"buildbock",children:"BuildBock"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"BuildBlock"})," builds a new block and returns it. This is mainly requested by the consensus engine."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:'// BuildBlock returns a block that this vm wants to add to consensus\nfunc (vm *VM) BuildBlock() (snowman.Block, error) {\n\tif len(vm.mempool) == 0 { // There is no block to be built\n\t\treturn nil, errNoPendingBlocks\n\t}\n\n\t// Get the value to put in the new block\n\tvalue := vm.mempool[0]\n\tvm.mempool = vm.mempool[1:]\n\n\t// Notify consensus engine that there are more pending data for blocks\n\t// (if that is the case) when done building this block\n\tif len(vm.mempool) > 0 {\n\t\tdefer vm.NotifyBlockReady()\n\t}\n\n\t// Gets Preferred Block\n\tpreferredBlock, err := vm.getBlock(vm.preferred)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("couldn\'t get preferred block: %w", err)\n\t}\n\tpreferredHeight := preferredBlock.Height()\n\n\t// Build the block with preferred height\n\tnewBlock, err := vm.NewBlock(vm.preferred, preferredHeight+1, value, time.Now())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("couldn\'t build block: %w", err)\n\t}\n\n\t// Verifies block\n\tif err := newBlock.Verify(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn newBlock, nil\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"notifyblockready",children:"NotifyBlockReady"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"NotifyBlockReady"})," is a helper method that can send messages to the consensus engine through\n",(0,s.jsx)(t.code,{children:"toEngine"})," channel."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:'// NotifyBlockReady tells the consensus engine that a new block\n// is ready to be created\nfunc (vm *VM) NotifyBlockReady() {\n\tselect {\n\tcase vm.toEngine <- common.PendingTxs:\n\tdefault:\n\t\tvm.ctx.Log.Debug("dropping message to consensus engine")\n\t}\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"getblock",children:"GetBlock"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"GetBlock"})," returns the block with the given block ID."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:"// GetBlock implements the snowman.ChainVM interface\nfunc (vm *VM) GetBlock(blkID ids.ID) (snowman.Block, error) { return vm.getBlock(blkID) }\n\nfunc (vm *VM) getBlock(blkID ids.ID) (*Block, error) {\n\t// If block is in memory, return it.\n\tif blk, exists := vm.verifiedBlocks[blkID]; exists {\n\t\treturn blk, nil\n\t}\n\n\treturn vm.state.GetBlock(blkID)\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"proposeblock",children:(0,s.jsx)(t.code,{children:"proposeBlock"})}),"\n",(0,s.jsxs)(t.p,{children:["This method adds a piece of data to the mempool and notifies the consensus layer of the blockchain\nthat a new block is ready to be built and voted on. This is called by API method ",(0,s.jsx)(t.code,{children:"ProposeBlock"}),",\nwhich we\u2019ll see later."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:"// proposeBlock appends [data] to [p.mempool].\n// Then it notifies the consensus engine\n// that a new block is ready to be added to consensus\n// (namely, a block with data [data])\nfunc (vm *VM) proposeBlock(data [dataLen]byte) {\n    vm.mempool = append(vm.mempool, data)\n    vm.NotifyBlockReady()\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"parseblock",children:"ParseBlock"}),"\n",(0,s.jsx)(t.p,{children:"Parse a block from its byte representation."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:"// ParseBlock parses [bytes] to a snowman.Block\n// This function is used by the vm's state to unmarshal blocks saved in state\n// and by the consensus layer when it receives the byte representation of a block\n// from another node\nfunc (vm *VM) ParseBlock(bytes []byte) (snowman.Block, error) {\n\t// A new empty block\n\tblock := &Block{}\n\n\t// Unmarshal the byte repr. of the block into our empty block\n\t_, err := Codec.Unmarshal(bytes, block)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Initialize the block\n\tblock.Initialize(bytes, choices.Processing, vm)\n\n\tif blk, err := vm.getBlock(block.ID()); err == nil {\n\t\t// If we have seen this block before, return it with the most up-to-date\n\t\t// info\n\t\treturn blk, nil\n\t}\n\n\t// Return the block\n\treturn block, nil\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"newblock",children:"NewBlock"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"NewBlock"})," creates a new block with given block parameters."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:"// NewBlock returns a new Block where:\n// - the block's parent is [parentID]\n// - the block's data is [data]\n// - the block's timestamp is [timestamp]\nfunc (vm *VM) NewBlock(parentID ids.ID, height uint64, data [dataLen]byte, timestamp time.Time) (*Block, error) {\n\tblock := &Block{\n\t\tPrntID: parentID,\n\t\tHght:   height,\n\t\tTmstmp: timestamp.Unix(),\n\t\tDt:     data,\n\t}\n\n\t// Get the byte representation of the block\n\tblockBytes, err := Codec.Marshal(CodecVersion, block)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Initialize the block by providing it with its byte representation\n\t// and a reference to this VM\n\tblock.Initialize(blockBytes, choices.Processing, vm)\n\treturn block, nil\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"setpreference",children:"SetPreference"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"SetPreference"})," implements the ",(0,s.jsx)(t.code,{children:"block.ChainVM"}),". It sets the preferred block ID."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:"// SetPreference sets the block with ID [ID] as the preferred block\nfunc (vm *VM) SetPreference(id ids.ID) error {\n\tvm.preferred = id\n\treturn nil\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"other-functions",children:"Other Functions"}),"\n",(0,s.jsxs)(t.p,{children:["These functions needs to be implemented for ",(0,s.jsx)(t.code,{children:"block.ChainVM"}),". Most of them are just blank functions\nreturning ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/vm.go"',children:"// Bootstrapped marks this VM as bootstrapped\nfunc (vm *VM) Bootstrapped() error { return nil }\n\n// Bootstrapping marks this VM as bootstrapping\nfunc (vm *VM) Bootstrapping() error { return nil }\n\n// Returns this VM's version\nfunc (vm *VM) Version() (string, error) {\n\treturn Version.String(), nil\n}\n\nfunc (vm *VM) Connected(id ids.ShortID, nodeVersion version.Application) error {\n\treturn nil // noop\n}\n\nfunc (vm *VM) Disconnected(id ids.ShortID) error {\n\treturn nil // noop\n}\n\n// This VM doesn't (currently) have any app-specific messages\nfunc (vm *VM) AppGossip(nodeID ids.ShortID, msg []byte) error {\n\treturn nil\n}\n\n// This VM doesn't (currently) have any app-specific messages\nfunc (vm *VM) AppRequest(nodeID ids.ShortID, requestID uint32, time time.Time, request []byte) error {\n\treturn nil\n}\n\n// This VM doesn't (currently) have any app-specific messages\nfunc (vm *VM) AppResponse(nodeID ids.ShortID, requestID uint32, response []byte) error {\n\treturn nil\n}\n\n// This VM doesn't (currently) have any app-specific messages\nfunc (vm *VM) AppRequestFailed(nodeID ids.ShortID, requestID uint32) error {\n\treturn nil\n}\n\n// Health implements the common.VM interface\nfunc (vm *VM) HealthCheck() (interface{}, error) { return nil, nil }\n"})}),"\n",(0,s.jsx)(t.h3,{id:"factory",children:"Factory"}),"\n",(0,s.jsxs)(t.p,{children:["VMs should implement the ",(0,s.jsx)(t.code,{children:"Factory"})," interface. ",(0,s.jsx)(t.code,{children:"New"})," method in the interface returns a new VM instance."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/factory.go"',children:"var _ vms.Factory = &Factory{}\n\n// Factory ...\ntype Factory struct{}\n\n// New ...\nfunc (f *Factory) New(*snow.Context) (interface{}, error) { return &VM{}, nil }\n"})}),"\n",(0,s.jsx)(t.h3,{id:"static-api",children:"Static API"}),"\n",(0,s.jsxs)(t.p,{children:["A VM may have a static API, which allows clients to call methods that do not query or update the\nstate of a particular blockchain, but rather apply to the VM as a whole. This is analogous to static\nmethods in computer programming. Luxd uses ",(0,s.jsx)(t.a,{href:"https://www.gorillatoolkit.org/pkg/rpc",children:"Gorilla\u2019s RPC\nlibrary"})," to implement HTTP APIs."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"StaticService"})," implements the static API for our VM."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/static_service.go"',children:"// StaticService defines the static API for the timestamp vm\ntype StaticService struct{}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"encode",children:"Encode"}),"\n",(0,s.jsx)(t.p,{children:"For each API method, there is:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"A struct that defines the method\u2019s arguments"}),"\n",(0,s.jsx)(t.li,{children:"A struct that defines the method\u2019s return values"}),"\n",(0,s.jsx)(t.li,{children:"A method that implements the API method, and is parameterized on the above 2 structs"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This API method encodes a string to its byte representation using a given encoding scheme. It can be\nused to encode data that is then put in a block and proposed as the next block for this chain."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/static_service.go"',children:'// EncodeArgs are arguments for Encode\ntype EncodeArgs struct {\n    Data     string              `json:"data"`\n    Encoding formatting.Encoding `json:"encoding"`\n    Length   int32               `json:"length"`\n}\n\n// EncodeReply is the reply from Encoder\ntype EncodeReply struct {\n    Bytes    string              `json:"bytes"`\n    Encoding formatting.Encoding `json:"encoding"`\n}\n\n// Encoder returns the encoded data\nfunc (ss *StaticService) Encode(_ *http.Request, args *EncodeArgs, reply *EncodeReply) error {\n    if len(args.Data) == 0 {\n        return fmt.Errorf("argument Data cannot be empty")\n    }\n    var argBytes []byte\n    if args.Length > 0 {\n        argBytes = make([]byte, args.Length)\n        copy(argBytes, args.Data)\n    } else {\n        argBytes = []byte(args.Data)\n    }\n\n    bytes, err := formatting.EncodeWithChecksum(args.Encoding, argBytes)\n    if err != nil {\n        return fmt.Errorf("couldn\'t encode data as string: %s", err)\n    }\n    reply.Bytes = bytes\n    reply.Encoding = args.Encoding\n    return nil\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"decode",children:"Decode"}),"\n",(0,s.jsxs)(t.p,{children:["This API method is the inverse of ",(0,s.jsx)(t.code,{children:"Encode"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/static_service.go"',children:'// DecoderArgs are arguments for Decode\ntype DecoderArgs struct {\n    Bytes    string              `json:"bytes"`\n    Encoding formatting.Encoding `json:"encoding"`\n}\n\n// DecoderReply is the reply from Decoder\ntype DecoderReply struct {\n    Data     string              `json:"data"`\n    Encoding formatting.Encoding `json:"encoding"`\n}\n\n// Decoder returns the Decoded data\nfunc (ss *StaticService) Decode(_ *http.Request, args *DecoderArgs, reply *DecoderReply) error {\n    bytes, err := formatting.Decode(args.Encoding, args.Bytes)\n    if err != nil {\n        return fmt.Errorf("couldn\'t Decode data as string: %s", err)\n    }\n    reply.Data = string(bytes)\n    reply.Encoding = args.Encoding\n    return nil\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"api",children:"API"}),"\n",(0,s.jsx)(t.p,{children:"A VM may also have a non-static HTTP API, which allows clients to query and update the blockchain's state."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Service"}),"'s declaration is:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/service.go"',children:"// Service is the API service for this VM\ntype Service struct{ vm *VM }\n"})}),"\n",(0,s.jsx)(t.p,{children:"Note that this struct has a reference to the VM, so it can query and update state."}),"\n",(0,s.jsx)(t.p,{children:"This VM's API has two methods. One allows a client to get a block by its ID. The other allows a\nclient to propose the next block of this blockchain. The blockchain ID in the endpoint changes,\nsince every blockchain has an unique ID."}),"\n",(0,s.jsx)(t.h4,{id:"timestampvmgetblock",children:(0,s.jsx)(t.code,{children:"timestampvm.getBlock"})}),"\n",(0,s.jsx)(t.p,{children:"Get a block by its ID. If no ID is provided, get the latest block."}),"\n",(0,s.jsxs)(t.h5,{id:"getblock-signature",children:[(0,s.jsx)(t.code,{children:"getBlock"})," Signature"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"timestampvm.getBlock({id: string}) ->\n    {\n        id: string,\n        data: string,\n        timestamp: int,\n        parentID: string\n    }\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"id"})," is the ID of the block being retrieved. If omitted from arguments, gets the latest block"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"data"})," is the base 58 (with checksum) representation of the block\u2019s 32 byte payload"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"timestamp"})," is the Unix timestamp when this block was created"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"parentID"})," is the block\u2019s parent"]}),"\n"]}),"\n",(0,s.jsxs)(t.h5,{id:"getblock-example-call",children:[(0,s.jsx)(t.code,{children:"getBlock"})," Example Call"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'curl -X POST --data \'{\n    "jsonrpc": "2.0",\n    "method": "timestampvm.getBlock",\n    "params":{\n        "id":"xqQV1jDnCXDxhfnNT7tDBcXeoH2jC3Hh7Pyv4GXE1z1hfup5K"\n    },\n    "id": 1\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/bc/sw813hGSWH8pdU9uzaYy9fCtYFfY7AjDd2c9rm64SbApnvjmk\n'})}),"\n",(0,s.jsxs)(t.h5,{id:"getblock-example-response",children:[(0,s.jsx)(t.code,{children:"getBlock"})," Example Response"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "jsonrpc": "2.0",\n  "result": {\n    "timestamp": "1581717416",\n    "data": "11111111111111111111111111111111LpoYY",\n    "id": "xqQV1jDnCXDxhfnNT7tDBcXeoH2jC3Hh7Pyv4GXE1z1hfup5K",\n    "parentID": "22XLgiM5dfCwTY9iZnVk8ZPuPe3aSrdVr5Dfrbxd3ejpJd7oef"\n  },\n  "id": 1\n}\n'})}),"\n",(0,s.jsxs)(t.h5,{id:"getblock-implementation",children:[(0,s.jsx)(t.code,{children:"getBlock"})," Implementation"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/service.go"',children:'// GetBlockArgs are the arguments to GetBlock\ntype GetBlockArgs struct {\n\t// ID of the block we\'re getting.\n\t// If left blank, gets the latest block\n\tID *ids.ID `json:"id"`\n}\n\n// GetBlockReply is the reply from GetBlock\ntype GetBlockReply struct {\n\tTimestamp json.Uint64 `json:"timestamp"` // Timestamp of most recent block\n\tData      string      `json:"data"`      // Data in the most recent block. Base 58 repr. of 5 bytes.\n\tID        ids.ID      `json:"id"`        // String repr. of ID of the most recent block\n\tParentID  ids.ID      `json:"parentID"`  // String repr. of ID of the most recent block\'s parent\n}\n\n// GetBlock gets the block whose ID is [args.ID]\n// If [args.ID] is empty, get the latest block\nfunc (s *Service) GetBlock(_ *http.Request, args *GetBlockArgs, reply *GetBlockReply) error {\n\t// If an ID is given, parse its string representation to an ids.ID\n\t// If no ID is given, ID becomes the ID of last accepted block\n\tvar (\n\t\tid  ids.ID\n\t\terr error\n\t)\n\n\tif args.ID == nil {\n\t\tid, err = s.vm.state.GetLastAccepted()\n\t\tif err != nil {\n\t\t\treturn errCannotGetLastAccepted\n\t\t}\n\t} else {\n\t\tid = *args.ID\n\t}\n\n\t// Get the block from the database\n\tblock, err := s.vm.getBlock(id)\n\tif err != nil {\n\t\treturn errNoSuchBlock\n\t}\n\n\t// Fill out the response with the block\'s data\n\treply.ID = block.ID()\n\treply.Timestamp = json.Uint64(block.Timestamp().Unix())\n\treply.ParentID = block.Parent()\n\tdata := block.Data()\n\treply.Data, err = formatting.EncodeWithChecksum(formatting.CB58, data[:])\n\n\treturn err\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"timestampvmproposeblock",children:(0,s.jsx)(t.code,{children:"timestampvm.proposeBlock"})}),"\n",(0,s.jsx)(t.p,{children:"Propose the next block on this blockchain."}),"\n",(0,s.jsxs)(t.h5,{id:"proposeblock-signature",children:[(0,s.jsx)(t.code,{children:"proposeBlock"})," Signature"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"timestampvm.proposeBlock({data: string}) -> {success: bool}\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"data"})," is the base 58 (with checksum) representation of the proposed block\u2019s 32 byte payload."]}),"\n"]}),"\n",(0,s.jsxs)(t.h5,{id:"proposeblock-example-call",children:[(0,s.jsx)(t.code,{children:"proposeBlock"})," Example Call"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'curl -X POST --data \'{\n    "jsonrpc": "2.0",\n    "method": "timestampvm.proposeBlock",\n    "params":{\n        "data":"SkB92YpWm4Q2iPnLGCuDPZPgUQMxajqQQuz91oi3xD984f8r"\n    },\n    "id": 1\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/bc/sw813hGSWH8pdU9uzaYy9fCtYFfY7AjDd2c9rm64SbApnvjmk\n'})}),"\n",(0,s.jsxs)(t.h6,{id:"proposeblock-example-response",children:[(0,s.jsx)(t.code,{children:"proposeBlock"})," Example Response"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "jsonrpc": "2.0",\n  "result": {\n    "Success": true\n  },\n  "id": 1\n}\n'})}),"\n",(0,s.jsxs)(t.h5,{id:"proposeblock-implementation",children:[(0,s.jsx)(t.code,{children:"proposeBlock"})," Implementation"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/timestampvm/service.go"',children:"// ProposeBlockArgs are the arguments to ProposeValue\ntype ProposeBlockArgs struct {\n    // Data for the new block. Must be base 58 encoding (with checksum) of 32 bytes.\n    Data string\n}\n\n// ProposeBlockReply is the reply from function ProposeBlock\ntype ProposeBlockReply struct{\n    // True if the operation was successful\n    Success bool\n}\n\n// ProposeBlock is an API method to propose a new block whose data is [args].Data.\n// [args].Data must be a string repr. of a 32 byte array\nfunc (s *Service) ProposeBlock(_ *http.Request, args *ProposeBlockArgs, reply *ProposeBlockReply) error {\n\tbytes, err := formatting.Decode(formatting.CB58, args.Data)\n\tif err != nil || len(bytes) != dataLen {\n\t\treturn errBadData\n\t}\n\n\tvar data [dataLen]byte         // The data as an array of bytes\n\tcopy(data[:], bytes[:dataLen]) // Copy the bytes in dataSlice to data\n\n\ts.vm.proposeBlock(data)\n\treply.Success = true\n\treturn nil\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"plugin",children:"Plugin"}),"\n",(0,s.jsxs)(t.p,{children:["In order to make this VM compatible with ",(0,s.jsx)(t.code,{children:"go-plugin"}),", we need to define a ",(0,s.jsx)(t.code,{children:"main"})," package and method,\nwhich serves our VM over gRPC so that Luxd can call its methods."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"main.go"}),"'s contents are:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",metastring:'title="/main/main.go"',children:'func main() {\n    log.Root().SetHandler(log.LvlFilterHandler(log.LvlDebug, log.StreamHandler(os.Stderr, log.TerminalFormat())))\n    plugin.Serve(&plugin.ServeConfig{\n        HandshakeConfig: rpcchainvm.Handshake,\n        Plugins: map[string]plugin.Plugin{\n            "vm": rpcchainvm.New(&timestampvm.VM{}),\n        },\n\n        // A non-nil value here enables gRPC serving for this plugin...\n        GRPCServer: plugin.DefaultGRPCServer,\n    })\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Now Luxd's ",(0,s.jsx)(t.code,{children:"rpcchainvm"})," can connect to this plugin and calls its methods."]}),"\n",(0,s.jsx)(t.h3,{id:"executable-binary",children:"Executable Binary"}),"\n",(0,s.jsxs)(t.p,{children:["This VM has a ",(0,s.jsx)(t.a,{href:"https://github.com/luxfi/timestampvm/blob/v1.2.1/scripts/build.sh",children:"build script"}),"\nthat builds an executable of this VM (when invoked, it runs the ",(0,s.jsx)(t.code,{children:"main"})," method from above.)"]}),"\n",(0,s.jsx)(t.p,{children:"The path to the executable, as well as its name, can be provided to the build script via arguments.\nFor example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"./scripts/build.sh ../luxd/build/plugins timestampvm\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If no argument is given, the path defaults to a binary named with default VM ID:\n",(0,s.jsx)(t.code,{children:"$GOPATH/src/github.com/luxfi/luxd/build/plugins/tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH"})]}),"\n",(0,s.jsxs)(t.p,{children:["This name ",(0,s.jsx)(t.code,{children:"tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH"}),' is the CB58 encoded 32 byte identifier\nfor the VM. For the timestampvm, this is the string "timestamp" zero-extended in a 32 byte array\nand encoded in CB58.']}),"\n",(0,s.jsx)(t.h3,{id:"vm-aliases",children:"VM Aliases"}),"\n",(0,s.jsxs)(t.p,{children:["Each VM has a predefined, static ID. For instance, the default ID of the TimestampVM is:\n",(0,s.jsx)(t.code,{children:"tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["It's possible to give an alias for these IDs. For example, we can alias ",(0,s.jsx)(t.code,{children:"TimestampVM"})," by creating a\nJSON file at ",(0,s.jsx)(t.code,{children:"~/.luxd/configs/vms/aliases.json"})," with:"]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"The name of the VM binary is also its static ID and should not be changed manually.\nChanging the name of the VM binary will result in Luxd failing to start the VM.\nTo reference a VM by another name, define a VM alias as described below."})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH": [\n    "timestampvm",\n    "timestamp"\n  ]\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"installing-a-vm",children:"Installing a VM"}),"\n",(0,s.jsxs)(t.p,{children:["Luxd searches for and registers plugins under the ",(0,s.jsx)(t.code,{children:"plugins"})," ",(0,s.jsx)(t.a,{href:"/docs/nodes/configure/luxd-config-flags#--plugin-dir-string",children:"directory"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"To install the virtual machine onto your node, you need to move the built virtual machine binary\nunder this directory. Virtual machine executable names must be either a full virtual machine ID\n(encoded in CB58), or a VM alias."}),"\n",(0,s.jsx)(t.p,{children:"Copy the binary into the plugins directory."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"cp -n <path to your binary> $GOPATH/src/github.com/luxfi/luxd/build/plugins/\n"})}),"\n",(0,s.jsx)(t.h4,{id:"node-is-not-running",children:"Node Is Not Running"}),"\n",(0,s.jsxs)(t.p,{children:["If your node isn't running yet, you can install all virtual machines under your ",(0,s.jsx)(t.code,{children:"plugin"})," directory\nby starting the node."]}),"\n",(0,s.jsx)(t.h4,{id:"node-is-already-running",children:"Node Is Already Running"}),"\n",(0,s.jsxs)(t.p,{children:["Load the binary with the ",(0,s.jsx)(t.code,{children:"loadVMs"})," API."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'curl -sX POST --data \'{\n    "jsonrpc":"2.0",\n    "id"     :1,\n    "method" :"admin.loadVMs",\n    "params" :{}\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/admin\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Confirm the response of ",(0,s.jsx)(t.code,{children:"loadVMs"})," contains the newly installed virtual machine\n",(0,s.jsx)(t.code,{children:"tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH"}),". You'll see this virtual machine as well as any\nothers that weren't already installed previously in the response."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "jsonrpc": "2.0",\n  "result": {\n    "newVMs": {\n      "tGas3T58KzdjLHhBDMnH2TvrddhqTji5iZAMZ3RXs2NLpSnhH": [\n        "timestampvm",\n        "timestamp"\n      ],\n      "spdxUxVJQbX85MGxMHbKw1sHxMnSqJ3QBzDyDYEP3h6TLuxqQ": []\n    }\n  },\n  "id": 1\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Now, this VM's static API can be accessed at endpoints ",(0,s.jsx)(t.code,{children:"/ext/vm/timestampvm"})," and\n",(0,s.jsx)(t.code,{children:"/ext/vm/timestamp"}),". For more details about VM configs, see\n",(0,s.jsx)(t.a,{href:"/docs/nodes/configure/luxd-config-flags#vm-configs",children:"here"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["In this tutorial, we used the VM's ID as the executable name to simplify the process. However,\nLuxd would also accept ",(0,s.jsx)(t.code,{children:"timestampvm"})," or ",(0,s.jsx)(t.code,{children:"timestamp"})," since those are registered aliases in\nprevious step."]}),"\n",(0,s.jsx)(t.h2,{id:"wrapping-up",children:"Wrapping Up"}),"\n",(0,s.jsx)(t.p,{children:"That\u2019s it! That\u2019s the entire implementation of a VM which defines a blockchain-based timestamp server."}),"\n",(0,s.jsx)(t.p,{children:"In this tutorial, we learned:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"block.ChainVM"})," interface, which all VMs that define a linear chain must implement"]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"snowman.Block"})," interface, which all blocks that are part of a linear chain must implement"]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"rpcchainvm"})," type, which allows blockchains to run in their own processes."]}),"\n",(0,s.jsxs)(t.li,{children:["An actual implementation of ",(0,s.jsx)(t.code,{children:"block.ChainVM"})," and ",(0,s.jsx)(t.code,{children:"snowman.Block"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},43540:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(48318);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);
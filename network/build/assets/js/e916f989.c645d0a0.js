"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[9210],{30054:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var s=t(49214),i=t(43540);const a={tags:["Build","Virtual Machines"],description:"Learn how to develop virtual machines on Lux using Rust.",sidebar_label:"Rust VM",pagination_label:"Build a Rust VM",sidebar_position:3},r="How to Build a Simple Rust VM",l={id:"build/vm/create/rust-vm",title:"How to Build a Simple Rust VM",description:"Learn how to develop virtual machines on Lux using Rust.",source:"@site/docs/build/vm/create/rust-vm.md",sourceDirName:"build/vm/create",slug:"/build/vm/create/rust-vm",permalink:"/docs/build/vm/create/rust-vm",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/build/vm/create/rust-vm.md",tags:[{label:"Build",permalink:"/docs/tags/build"},{label:"Virtual Machines",permalink:"/docs/tags/virtual-machines"}],version:"current",sidebarPosition:3,frontMatter:{tags:["Build","Virtual Machines"],description:"Learn how to develop virtual machines on Lux using Rust.",sidebar_label:"Rust VM",pagination_label:"Build a Rust VM",sidebar_position:3},sidebar:"build-vm",previous:{title:"Build a Complex Golang VM",permalink:"/docs/build/vm/create/golang-vm-complex"},next:{title:"Introduction",permalink:"/docs/build/vm/evm/intro"}},o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Components",id:"components",level:2},{value:"TimestampVM RS Implementation",id:"timestampvm-rs-implementation",level:2},{value:"State",id:"state",level:3},{value:"Block",id:"block",level:3},{value:"<code>verify</code>",id:"verify",level:4},{value:"<code>accept</code>",id:"accept",level:4},{value:"<code>reject</code>",id:"reject",level:4},{value:"Block Field Methods",id:"block-field-methods",level:4},{value:"Helper Functions",id:"helper-functions",level:4},{value:"<code>init</code>",id:"init",level:4},{value:"<code>set_status</code>",id:"set_status",level:4},{value:"Coding the Virtual Machine",id:"coding-the-virtual-machine",level:3},{value:"<code>initialize</code>",id:"initialize",level:4},{value:"<code>create_handlers</code>",id:"create_handlers",level:4},{value:"<code>create_static_handlers</code>",id:"create_static_handlers",level:4},{value:"<code>build_block</code>",id:"build_block",level:4},{value:"<code>notify_block_ready</code>",id:"notify_block_ready",level:4},{value:"<code>get_block</code>",id:"get_block",level:4},{value:"<code>propose_block</code>",id:"propose_block",level:4},{value:"<code>parse_block</code>",id:"parse_block",level:4},{value:"<code>set_preference</code>",id:"set_preference",level:4},{value:"Mempool",id:"mempool",level:3},{value:"Static API",id:"static-api",level:3},{value:"API",id:"api",level:3},{value:"<code>timestampvm.getBlock</code>",id:"timestampvmgetblock",level:4},{value:"<code>timestampvm.proposeBlock</code>",id:"timestampvmproposeblock",level:4},{value:"<code>timestampvm.lastAccepted</code>",id:"timestampvmlastaccepted",level:4},{value:"Plugin",id:"plugin",level:3},{value:"Installing a VM",id:"installing-a-vm",level:3},{value:"Node Is Not Running",id:"node-is-not-running",level:4},{value:"Node Is Already Running",id:"node-is-already-running",level:4},{value:"Wrapping Up",id:"wrapping-up",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"how-to-build-a-simple-rust-vm",children:"How to Build a Simple Rust VM"}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["The Lux Rust SDK is a developer toolkit composed of powerful building blocks and primitive\ntypes. This tutorial will walk you through the creation of a simple VM known as the ",(0,s.jsx)(n.a,{href:"https://github.com/luxfi/timestampvm-rs",children:"TimestampVM RS"})," using the Rust SDK. Each block in the TimestampVM's\nblockchain contains a monotonically increasing timestamp when the block was created and a 32-byte\npayload of data."]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Install the latest stable version of Rust using ",(0,s.jsx)(n.a,{href:"https://www.rust-lang.org/tools/install",children:(0,s.jsx)(n.code,{children:"rustup"})}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Bookmark and review the ",(0,s.jsx)(n.a,{href:"https://github.com/luxfi/rs",children:"rs"})," GitHub\nrepository, specifically the Subnet traits and helpers defined in the ",(0,s.jsx)(n.code,{children:"types"})," crate"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["For developers new to Rust please visit the free online book ",(0,s.jsx)(n.a,{href:"https://doc.rust-lang.org/book/",children:"The Rust Programming\nLanguage"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The example VMs in these tutorials are based on\n",(0,s.jsx)(n.a,{href:"https://github.com/luxfi/types-rs",children:"types-rs"}),", a predecessor of\nthe ",(0,s.jsx)(n.a,{href:"https://github.com/luxfi/rs",children:"rs"})," repository that is now the\naccepted standard. Directory locations will vary."]})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If you have experimented with our Golang example VMs you will find the Rust SDK fairly familiar.\nCompletely new to creating a custom VM on Lux? No problem please review ",(0,s.jsx)(n.a,{href:"/docs/build/vm/intro",children:"Introduction to VMs"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,s.jsx)(n.p,{children:"A VM defines how a blockchain should be built. A block is populated with a transaction which mutates\nthe state of the blockchain when executed. By executing a series of blocks chronologically, anyone\ncan verify and reconstruct the state of the blockchain at an arbitrary point in time."}),"\n",(0,s.jsx)(n.p,{children:"The TimestampVM RS repository has a few components to handle the lifecycle of tasks from a\ntransaction being issued to a block being accepted across the network:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mempool"})," - Stores pending transactions that haven't been finalized yet."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Block"})," - Defines the block format, how to verify it, and how it should be accepted or rejected\nacross the network"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Virtual Machine"})," - Application-level logic. Implements the VM trait needed to interact with\nLux consensus and defines the blueprint for the blockchain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service"})," - Exposes APIs so users can interact with the VM."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State"})," - Manages both in memory and persistent states."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"timestampvm-rs-implementation",children:"TimestampVM RS Implementation"}),"\n",(0,s.jsxs)(n.p,{children:["The TimestampVM RS implements the\n",(0,s.jsx)(n.a,{href:"https://github.com/luxfi/types-rs/blob/main/src/subnet/rpc/snowman/block.rs",children:"snowman::block::ChainVM"}),"\ntrait. Below you will find additional documentation on the trait methods. To assist with a logical\nunderstanding of the expectations for these methods please see the code examples below."]}),"\n",(0,s.jsx)(n.p,{children:"Additional Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://pkg.go.dev/github.com/luxfi/luxd/snow/engine/snowman/block#ChainVm",children:"ChainVM\nGoDoc"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://buf.build/luxfi/lux/docs/main:vm#vm.VM",children:"Lux Proto Docs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/luxfi/luxd/tree/master/vms#snowman-vms",children:"Snowman VMs"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Now we know the traits (interfaces) our VM must implement and the libraries we can use to build a VM\nusing the Rust SDK."}),"\n",(0,s.jsxs)(n.p,{children:["Let\u2019s write our VM, which implements ",(0,s.jsx)(n.code,{children:"snowman::block::ChainVM"})," and whose blocks implement\n",(0,s.jsx)(n.code,{children:"snowman::Block"}),". You can also follow the code in the ",(0,s.jsx)(n.a,{href:"https://github.com/luxfi/timestampvm-rs",children:"TimestampVM RS\nrepository"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"state",children:"State"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"State"})," manages block and chain states for this VM, both in-memory and persistent."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/state/mod.rs"',children:'#[derive(Clone)]\npub struct State {\n    pub db: Arc<RwLock<Box<dyn subnet::rpc::database::Database + Send + Sync>>>,\n\n    /// Maps block Id to Block.\n    /// Each element is verified but not yet accepted/rejected (e.g., preferred).\n    pub verified_blocks: Arc<RwLock<HashMap<ids::Id, Block>>>,\n}\n\nimpl Default for State {\n    fn default() -> State {\n        Self {\n            db: Arc::new(RwLock::new(subnet::rpc::database::memdb::Database::new())),\n            verified_blocks: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n}\n\nconst LAST_ACCEPTED_BLOCK_KEY: &[u8] = b"last_accepted_block";\n\nconst STATUS_PREFIX: u8 = 0x0;\n\nconst DELIMITER: u8 = b\'/\';\n\n/// Returns a vec of bytes used as a key for identifying blocks in state.\n/// \'STATUS_PREFIX\' + \'BYTE_DELIMITER\' + [block_id]\nfn block_with_status_key(blk_id: &ids::Id) -> Vec<u8> {\n    let mut k: Vec<u8> = Vec::with_capacity(ids::LEN + 2);\n    k.push(STATUS_PREFIX);\n    k.push(DELIMITER);\n    k.extend_from_slice(&blk_id.to_vec());\n    k\n}\n\n/// Wraps a [`Block`](crate::block::Block) and its status.\n/// This is the data format that [`State`](State) uses to persist blocks.\n#[derive(Serialize, Deserialize, Clone)]\nstruct BlockWithStatus {\n    block_bytes: Vec<u8>,\n    status: choices::status::Status,\n}\n\nimpl BlockWithStatus {\n    fn encode(&self) -> io::Result<Vec<u8>> {\n        serde_json::to_vec(&self).map_err(|e| {\n            Error::new(\n                ErrorKind::Other,\n                format!("failed to serialize BlockStatus to JSON bytes: {}", e),\n            )\n        })\n    }\n\n    fn from_slice(d: impl AsRef<[u8]>) -> io::Result<Self> {\n        let dd = d.as_ref();\n        serde_json::from_slice(dd).map_err(|e| {\n            Error::new(\n                ErrorKind::Other,\n                format!("failed to deserialize BlockStatus from JSON: {}", e),\n            )\n        })\n    }\n}\n\nimpl State {\n    /// Persists the last accepted block Id.\n    pub async fn set_last_accepted_block(&self, blk_id: &ids::Id) -> io::Result<()> {\n        let mut db = self.db.write().await;\n        db.put(LAST_ACCEPTED_BLOCK_KEY, &blk_id.to_vec())\n            .await\n            .map_err(|e| {\n                Error::new(\n                    ErrorKind::Other,\n                    format!("failed to put last accepted block: {:?}", e),\n                )\n            })\n    }\n\n    /// Returns "true" if there\'s a last accepted block found.\n    pub async fn has_last_accepted_block(&self) -> io::Result<bool> {\n        let db = self.db.read().await;\n        match db.has(LAST_ACCEPTED_BLOCK_KEY).await {\n            Ok(found) => Ok(found),\n            Err(e) => Err(Error::new(\n                ErrorKind::Other,\n                format!("failed to load last accepted block: {}", e),\n            )),\n        }\n    }\n\n    /// Returns the last accepted block Id.\n    pub async fn get_last_accepted_block_id(&self) -> io::Result<ids::Id> {\n        let db = self.db.read().await;\n        match db.get(LAST_ACCEPTED_BLOCK_KEY).await {\n            Ok(d) => Ok(ids::Id::from_slice(&d)),\n            Err(e) => {\n                if subnet::rpc::database::errors::is_not_found(&e) {\n                    return Ok(ids::Id::empty());\n                }\n                Err(e)\n            }\n        }\n    }\n\n    /// Adds a block to "verified_blocks".\n    pub async fn add_verified(&mut self, block: &Block) {\n        let blk_id = block.id();\n        log::info!("verified added {blk_id}");\n\n        let mut verified_blocks = self.verified_blocks.write().await;\n        verified_blocks.insert(blk_id, block.clone());\n    }\n\n    /// Removes a block from "verified_blocks".\n    pub async fn remove_verified(&mut self, blk_id: &ids::Id) {\n        let mut verified_blocks = self.verified_blocks.write().await;\n        verified_blocks.remove(blk_id);\n    }\n\n    /// Returns "true" if the block Id has been already verified.\n    pub async fn has_verified(&self, blk_id: &ids::Id) -> bool {\n        let verified_blocks = self.verified_blocks.read().await;\n        verified_blocks.contains_key(blk_id)\n    }\n\n    /// Writes a block to the state storage.\n    pub async fn write_block(&mut self, block: &Block) -> io::Result<()> {\n        let blk_id = block.id();\n        let blk_bytes = block.to_slice()?;\n\n        let mut db = self.db.write().await;\n\n        let blk_status = BlockWithStatus {\n            block_bytes: blk_bytes,\n            status: block.status(),\n        };\n        let blk_status_bytes = blk_status.encode()?;\n\n        db.put(&block_with_status_key(&blk_id), &blk_status_bytes)\n            .await\n            .map_err(|e| Error::new(ErrorKind::Other, format!("failed to put block: {:?}", e)))\n    }\n\n    /// Reads a block from the state storage using the block_with_status_key.\n    pub async fn get_block(&self, blk_id: &ids::Id) -> io::Result<Block> {\n        // check if the block exists in memory as previously verified.\n        let verified_blocks = self.verified_blocks.read().await;\n        if let Some(b) = verified_blocks.get(blk_id) {\n            return Ok(b.clone());\n        }\n\n        let db = self.db.read().await;\n\n        let blk_status_bytes = db.get(&block_with_status_key(blk_id)).await?;\n        let blk_status = BlockWithStatus::from_slice(&blk_status_bytes)?;\n\n        let mut blk = Block::from_slice(&blk_status.block_bytes)?;\n        blk.set_status(blk_status.status);\n\n        Ok(blk)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"block",children:"Block"}),"\n",(0,s.jsxs)(n.p,{children:["This implementation of ",(0,s.jsx)(n.code,{children:"snowman::Block"})," provides the VM with storage, retrieval and status of blocks."]}),"\n",(0,s.jsx)(n.p,{children:"Block is a block on the chain.\nEach block contains:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ParentID"}),"\n",(0,s.jsx)(n.li,{children:"Height"}),"\n",(0,s.jsx)(n.li,{children:"Timestamp"}),"\n",(0,s.jsx)(n.li,{children:"A piece of data (hex encoded string)"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/block/mod.rs"',children:'#[serde_as]\n#[derive(Serialize, Deserialize, Clone, Derivative)]\n#[derivative(Debug, PartialEq, Eq)]\npub struct Block {\n    /// The block Id of the parent block.\n    parent_id: ids::Id,\n    /// This block\'s height.\n    /// The height of the genesis block is 0.\n    height: u64,\n    /// Unix second when this block was proposed.\n    timestamp: u64,\n    /// Arbitrary data.\n    #[serde_as(as = "Hex0xBytes")]\n    data: Vec<u8>,\n\n    /// Current block status.\n    #[serde(skip)]\n    status: choices::status::Status,\n    /// This block\'s encoded bytes.\n    #[serde(skip)]\n    bytes: Vec<u8>,\n    /// Generated block Id.\n    #[serde(skip)]\n    id: ids::Id,\n\n    /// Reference to the Vm state manager for blocks.\n    #[derivative(Debug = "ignore", PartialEq = "ignore")]\n    #[serde(skip)]\n    state: state::State,\n}\n\nimpl Default for Block {\n    fn default() -> Self {\n        Self::default()\n    }\n}\n\nimpl Block {\n    pub fn default() -> Self {\n        Self {\n            parent_id: ids::Id::empty(),\n            height: 0,\n            timestamp: 0,\n            data: Vec::new(),\n\n            status: choices::status::Status::default(),\n            bytes: Vec::new(),\n            id: ids::Id::empty(),\n\n            state: state::State::default(),\n        }\n    }\n\n    pub fn new(\n        parent_id: ids::Id,\n        height: u64,\n        timestamp: u64,\n        data: Vec<u8>,\n        status: choices::status::Status,\n    ) -> io::Result<Self> {\n        let mut b = Self {\n            parent_id,\n            height,\n            timestamp,\n            data,\n            ..Default::default()\n        };\n\n        b.status = status;\n        b.bytes = b.to_slice()?;\n        b.id = ids::Id::sha256(&b.bytes);\n\n        Ok(b)\n    }\n\n    pub fn to_json_string(&self) -> io::Result<String> {\n        serde_json::to_string(&self).map_err(|e| {\n            Error::new(\n                ErrorKind::Other,\n                format!("failed to serialize Block to JSON string {}", e),\n            )\n        })\n    }\n\n    /// Encodes the [`Block`](Block) to JSON in bytes.\n    pub fn to_slice(&self) -> io::Result<Vec<u8>> {\n        serde_json::to_vec(&self).map_err(|e| {\n            Error::new(\n                ErrorKind::Other,\n                format!("failed to serialize Block to JSON bytes {}", e),\n            )\n        })\n    }\n\n    /// Loads [`Block`](Block) from JSON bytes.\n    pub fn from_slice(d: impl AsRef<[u8]>) -> io::Result<Self> {\n        let dd = d.as_ref();\n        let mut b: Self = serde_json::from_slice(dd).map_err(|e| {\n            Error::new(\n                ErrorKind::Other,\n                format!("failed to deserialize Block from JSON {}", e),\n            )\n        })?;\n\n        b.bytes = dd.to_vec();\n        b.id = ids::Id::sha256(&b.bytes);\n\n        Ok(b)\n    }\n\n    /// Returns the parent block Id.\n    pub fn parent_id(&self) -> ids::Id {\n        self.parent_id\n    }\n\n    /// Returns the height of this block.\n    pub fn height(&self) -> u64 {\n        self.height\n    }\n\n    /// Returns the timestamp of this block.\n    pub fn timestamp(&self) -> u64 {\n        self.timestamp\n    }\n\n    /// Returns the data of this block.\n    pub fn data(&self) -> &[u8] {\n        &self.data\n    }\n\n    /// Returns the status of this block.\n    pub fn status(&self) -> choices::status::Status {\n        self.status.clone()\n    }\n\n    /// Updates the status of this block.\n    pub fn set_status(&mut self, status: choices::status::Status) {\n        self.status = status;\n    }\n\n    /// Returns the byte representation of this block.\n    pub fn bytes(&self) -> &[u8] {\n        &self.bytes\n    }\n\n    /// Returns the ID of this block\n    pub fn id(&self) -> ids::Id {\n        self.id\n    }\n\n    /// Updates the state of the block.\n    pub fn set_state(&mut self, state: state::State) {\n        self.state = state;\n    }\n\n    /// Verifies [`Block`](Block) properties (e.g., heights),\n    /// and once verified, records it to the [`State`](crate::state::State).\n    pub async fn verify(&mut self) -> io::Result<()> {\n        if self.height == 0 && self.parent_id == ids::Id::empty() {\n            log::debug!(\n                "block {} has an empty parent Id since it\'s a genesis block -- skipping verify",\n                self.id\n            );\n            self.state.add_verified(&self.clone()).await;\n            return Ok(());\n        }\n\n        // if already exists in database, it means it\'s already accepted\n        // thus no need to verify once more\n        if self.state.get_block(&self.id).await.is_ok() {\n            log::debug!("block {} already verified", self.id);\n            return Ok(());\n        }\n\n        let prnt_blk = self.state.get_block(&self.parent_id).await?;\n\n        // ensure the height of the block is immediately following its parent\n        if prnt_blk.height != self.height - 1 {\n            return Err(Error::new(\n                ErrorKind::InvalidData,\n                format!(\n                    "parent block height {} != current block height {} - 1",\n                    prnt_blk.height, self.height\n                ),\n            ));\n        }\n\n        // ensure block timestamp is after its parent\n        if prnt_blk.timestamp > self.timestamp {\n            return Err(Error::new(\n                ErrorKind::InvalidData,\n                format!(\n                    "parent block timestamp {} > current block timestamp {}",\n                    prnt_blk.timestamp, self.timestamp\n                ),\n            ));\n        }\n\n        // ensure block timestamp is no more than an hour ahead of this nodes time\n        if self.timestamp >= (Utc::now() + Duration::hours(1)).timestamp() as u64 {\n            return Err(Error::new(\n                ErrorKind::InvalidData,\n                format!(\n                    "block timestamp {} is more than 1 hour ahead of local time",\n                    self.timestamp\n                ),\n            ));\n        }\n\n        // add newly verified block to memory\n        self.state.add_verified(&self.clone()).await;\n        Ok(())\n    }\n\n    /// Mark this [`Block`](Block) accepted and updates [`State`](crate::state::State) accordingly.\n    pub async fn accept(&mut self) -> io::Result<()> {\n        self.set_status(choices::status::Status::Accepted);\n\n        // only decided blocks are persistent -- no reorg\n        self.state.write_block(&self.clone()).await?;\n        self.state.set_last_accepted_block(&self.id()).await?;\n\n        self.state.remove_verified(&self.id()).await;\n        Ok(())\n    }\n\n    /// Mark this [`Block`](Block) rejected and updates [`State`](crate::state::State) accordingly.\n    pub async fn reject(&mut self) -> io::Result<()> {\n        self.set_status(choices::status::Status::Rejected);\n\n        // only decided blocks are persistent -- no reorg\n        self.state.write_block(&self.clone()).await?;\n\n        self.state.remove_verified(&self.id()).await;\n        Ok(())\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"verify",children:(0,s.jsx)(n.code,{children:"verify"})}),"\n",(0,s.jsxs)(n.p,{children:["This method verifies that a block is valid and stores it in the memory. It is important to store the\nverified block in the memory and return them in the ",(0,s.jsx)(n.code,{children:"vm.get_block()"})," method."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/block/mod.rs"',children:'pub async fn verify(&mut self) -> io::Result<()> {\n    if self.height == 0 && self.parent_id == ids::Id::empty() {\n        log::debug!(\n            "block {} has an empty parent Id since it\'s a genesis block -- skipping verify",\n            self.id\n        );\n        self.state.add_verified(&self.clone()).await;\n        return Ok(());\n    }\n\n    // if already exists in database, it means it\'s already accepted\n    // thus no need to verify once more\n    if self.state.get_block(&self.id).await.is_ok() {\n        log::debug!("block {} already verified", self.id);\n        return Ok(());\n    }\n\n    let prnt_blk = self.state.get_block(&self.parent_id).await?;\n\n    // ensure the height of the block is immediately following its parent\n    if prnt_blk.height != self.height - 1 {\n        return Err(Error::new(\n            ErrorKind::InvalidData,\n            format!(\n                "parent block height {} != current block height {} - 1",\n                prnt_blk.height, self.height\n            ),\n        ));\n    }\n\n    // ensure block timestamp is after its parent\n    if prnt_blk.timestamp > self.timestamp {\n        return Err(Error::new(\n            ErrorKind::InvalidData,\n            format!(\n                "parent block timestamp {} > current block timestamp {}",\n                prnt_blk.timestamp, self.timestamp\n            ),\n        ));\n    }\n\n    // ensure block timestamp is no more than an hour ahead of this nodes time\n    if self.timestamp >= (Utc::now() + Duration::hours(1)).timestamp() as u64 {\n        return Err(Error::new(\n            ErrorKind::InvalidData,\n            format!(\n                "block timestamp {} is more than 1 hour ahead of local time",\n                self.timestamp\n            ),\n        ));\n    }\n\n    // add newly verified block to memory\n    self.state.add_verified(&self.clone()).await;\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"accept",children:(0,s.jsx)(n.code,{children:"accept"})}),"\n",(0,s.jsx)(n.p,{children:"Called by the consensus engine to indicate this block is accepted."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/block/mod.rs"',children:"pub async fn accept(&mut self) -> io::Result<()> {\n    self.set_status(choices::status::Status::Accepted);\n\n    // only decided blocks are persistent -- no reorg\n    self.state.write_block(&self.clone()).await?;\n    self.state.set_last_accepted_block(&self.id()).await?;\n\n    self.state.remove_verified(&self.id()).await;\n    Ok(())\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"reject",children:(0,s.jsx)(n.code,{children:"reject"})}),"\n",(0,s.jsx)(n.p,{children:"Called by the consensus engine to indicate the block is rejected."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/block/mod.rs"',children:"pub async fn reject(&mut self) -> io::Result<()> {\n    self.set_status(choices::status::Status::Rejected);\n\n    // only decided blocks are persistent -- no reorg\n    self.state.write_block(&self.clone()).await?;\n\n    self.state.remove_verified(&self.id()).await;\n    Ok(())\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"block-field-methods",children:"Block Field Methods"}),"\n",(0,s.jsxs)(n.p,{children:["These methods are required by the ",(0,s.jsx)(n.code,{children:"snowman::Block"})," trait."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/block/mod.rs"',children:"impl subnet::rpc::consensus::snowman::Block for Block {\n    async fn bytes(&self) -> &[u8] {\n        return self.bytes.as_ref();\n    }\n\n    async fn to_bytes(&self) -> io::Result<Vec<u8>> {\n        self.to_slice()\n    }\n\n    async fn height(&self) -> u64 {\n        self.height\n    }\n\n    async fn timestamp(&self) -> u64 {\n        self.timestamp\n    }\n\n    async fn parent(&self) -> ids::Id {\n        self.parent_id.clone()\n    }\n\n    async fn verify(&mut self) -> io::Result<()> {\n        self.verify().await\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,s.jsx)(n.p,{children:"These methods are convenience methods for blocks."}),"\n",(0,s.jsx)(n.h4,{id:"init",children:(0,s.jsx)(n.code,{children:"init"})}),"\n",(0,s.jsx)(n.p,{children:"Initializes a block from a bytes slice and status."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/block/mod.rs"',children:"impl subnet::rpc::consensus::snowman::Initializer for Block {\n    async fn init(&mut self, bytes: &[u8], status: choices::status::Status) -> io::Result<()> {\n        *self = Block::from_slice(bytes)?;\n        self.status = status;\n\n        Ok(())\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"set_status",children:(0,s.jsx)(n.code,{children:"set_status"})}),"\n",(0,s.jsx)(n.p,{children:"Updates the status of this block."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/block/mod.rs"',children:"impl subnet::rpc::consensus::snowman::StatusWriter for Block {\n    async fn set_status(&mut self, status: choices::status::Status) {\n        self.set_status(status)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"coding-the-virtual-machine",children:"Coding the Virtual Machine"}),"\n",(0,s.jsxs)(n.p,{children:["Now, let\u2019s look at our timestamp VM implementation, which implements the ",(0,s.jsx)(n.code,{children:"block::ChainVM"})," trait."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'pub struct Vm {\n    /// Maintains the Vm-specific states.\n    pub state: Arc<RwLock<VmState>>,\n    pub app_sender: Option<Box<dyn subnet::rpc::common::appsender::AppSender + Send + Sync>>,\n\n    /// A queue of data that have not been put into a block and proposed yet.\n    /// Mempool is not persistent, so just keep in memory via Vm.\n    pub mempool: Arc<RwLock<VecDeque<Vec<u8>>>>,\n}\n\n/// Represents VM-specific states.\n/// Defined in a separate struct, for interior mutability in [`Vm`](Vm).\n/// To be protected with `Arc` and `RwLock`.\npub struct VmState {\n    pub ctx: Option<subnet::rpc::context::Context>,\n    pub version: Version,\n    pub genesis: Genesis,\n\n    /// Represents persistent Vm state.\n    pub state: Option<state::State>,\n    /// Currently preferred block Id.\n    pub preferred: ids::Id,\n    /// Channel to send messages to the snowman consensus engine.\n    pub to_engine: Option<Sender<subnet::rpc::common::message::Message>>,\n    /// Set "true" to indicate that the Vm has finished bootstrapping\n    /// for the chain.\n    pub bootstrapped: bool,\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"initialize",children:(0,s.jsx)(n.code,{children:"initialize"})}),"\n",(0,s.jsx)(n.p,{children:"This method is called when a new instance of VM is initialized. Genesis block is created under this method."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'async fn initialize(\n    &mut self,\n    ctx: Option<subnet::rpc::context::Context>,\n    db_manager: Box<dyn subnet::rpc::database::manager::Manager + Send + Sync>,\n    genesis_bytes: &[u8],\n    _upgrade_bytes: &[u8],\n    _config_bytes: &[u8],\n    to_engine: Sender<subnet::rpc::common::message::Message>,\n    _fxs: &[subnet::rpc::common::vm::Fx],\n    app_sender: Box<dyn subnet::rpc::common::appsender::AppSender + Send + Sync>,\n) -> io::Result<()> {\n    log::info!("initializing Vm");\n    let mut vm_state = self.state.write().await;\n\n    vm_state.ctx = ctx;\n\n    let version =\n        Version::parse(VERSION).map_err(|e| Error::new(ErrorKind::Other, e.to_string()))?;\n    vm_state.version = version;\n\n    let genesis = Genesis::from_slice(genesis_bytes)?;\n    vm_state.genesis = genesis;\n\n    let current = db_manager.current().await?;\n    let state = state::State {\n        db: Arc::new(RwLock::new(current.db)),\n        verified_blocks: Arc::new(RwLock::new(HashMap::new())),\n    };\n    vm_state.state = Some(state.clone());\n\n    vm_state.to_engine = Some(to_engine);\n\n    self.app_sender = Some(app_sender);\n\n    let has_last_accepted = state.has_last_accepted_block().await?;\n    if has_last_accepted {\n        let last_accepted_blk_id = state.get_last_accepted_block_id().await?;\n        vm_state.preferred = last_accepted_blk_id;\n        log::info!("initialized Vm with last accepted block {last_accepted_blk_id}");\n    } else {\n        let mut genesis_block = Block::new(\n            ids::Id::empty(),\n            0,\n            0,\n            vm_state.genesis.data.as_bytes().to_vec(),\n            choices::status::Status::default(),\n        )?;\n        genesis_block.set_state(state.clone());\n        genesis_block.accept().await?;\n\n        let genesis_blk_id = genesis_block.id();\n        vm_state.preferred = genesis_blk_id;\n        log::info!("initialized Vm with genesis block {genesis_blk_id}");\n    }\n\n    self.mempool = Arc::new(RwLock::new(VecDeque::with_capacity(100)));\n\n    log::info!("successfully initialized Vm");\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"create_handlers",children:(0,s.jsx)(n.code,{children:"create_handlers"})}),"\n",(0,s.jsxs)(n.p,{children:["Registers handlers defined in ",(0,s.jsx)(n.code,{children:"api::chain_handlers::Service"}),". See\n",(0,s.jsx)(n.a,{href:"/docs/build/vm/create/rust-vm#api",children:"below"})," for more on APIs."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'/// Creates VM-specific handlers.\nasync fn create_handlers(\n    &mut self,\n) -> io::Result<HashMap<String, subnet::rpc::common::http_handler::HttpHandler>> {\n    let svc = api::chain_handlers::Service::new(self.clone());\n    let mut handler = jsonrpc_core::IoHandler::new();\n    handler.extend_with(api::chain_handlers::Rpc::to_delegate(svc));\n\n    let http_handler = subnet::rpc::common::http_handler::HttpHandler::new_from_u8(0, handler)\n        .map_err(|_| Error::from(ErrorKind::InvalidData))?;\n\n    let mut handlers = HashMap::new();\n    handlers.insert("/rpc".to_string(), http_handler);\n    Ok(handlers)\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"create_static_handlers",children:(0,s.jsx)(n.code,{children:"create_static_handlers"})}),"\n",(0,s.jsxs)(n.p,{children:["Registers handlers defined in ",(0,s.jsx)(n.code,{children:"api::chain_handlers::Service"}),". See\n",(0,s.jsx)(n.a,{href:"/docs/build/vm/create/rust-vm#api",children:"below"})," for more on APIs."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'async fn create_static_handlers(\n    &mut self,\n) -> io::Result<HashMap<String, subnet::rpc::common::http_handler::HttpHandler>> {\n    let svc = api::static_handlers::Service::new(self.clone());\n    let mut handler = jsonrpc_core::IoHandler::new();\n    handler.extend_with(api::static_handlers::Rpc::to_delegate(svc));\n\n    let http_handler = subnet::rpc::common::http_handler::HttpHandler::new_from_u8(0, handler)\n        .map_err(|_| Error::from(ErrorKind::InvalidData))?;\n\n    let mut handlers = HashMap::new();\n    handlers.insert("/static".to_string(), http_handler);\n    Ok(handlers)\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"build_block",children:(0,s.jsx)(n.code,{children:"build_block"})}),"\n",(0,s.jsx)(n.p,{children:"Builds a new block from mempool data and returns it. This is primarily requested by the consensus engine."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'async fn build_block(\n    &self,\n) -> io::Result<Box<dyn subnet::rpc::consensus::snowman::Block + Send + Sync>> {\n    let mut mempool = self.mempool.write().await;\n\n    log::info!("build_block called for {} mempool", mempool.len());\n    if mempool.is_empty() {\n        return Err(Error::new(ErrorKind::Other, "no pending block"));\n    }\n\n    let vm_state = self.state.read().await;\n    if let Some(state) = &vm_state.state {\n        self.notify_block_ready().await;\n\n        // "state" must have preferred block in cache/verified_block\n        // otherwise, not found error from rpcchainvm database\n        let prnt_blk = state.get_block(&vm_state.preferred).await?;\n        let unix_now = Utc::now().timestamp() as u64;\n\n        let first = mempool.pop_front().unwrap();\n        let mut block = Block::new(\n            prnt_blk.id(),\n            prnt_blk.height() + 1,\n            unix_now,\n            first,\n            choices::status::Status::Processing,\n        )?;\n        block.set_state(state.clone());\n        block.verify().await?;\n\n        log::info!("successfully built block");\n        return Ok(Box::new(block));\n    }\n\n    Err(Error::new(ErrorKind::NotFound, "state manager not found"))\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"notify_block_ready",children:(0,s.jsx)(n.code,{children:"notify_block_ready"})}),"\n",(0,s.jsxs)(n.p,{children:["Signals the consensus engine that a new block is ready to be created. After this is sent the\nconsensus engine will call back to ",(0,s.jsx)(n.code,{children:"vm.build_block"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'pub async fn notify_block_ready(&self) {\n    let vm_state = self.state.read().await;\n    if let Some(engine) = &vm_state.to_engine {\n        engine\n            .send(subnet::rpc::common::message::Message::PendingTxs)\n            .await\n            .unwrap_or_else(|e| log::warn!("dropping message to consensus engine: {}", e));\n\n        log::info!("notified block ready!");\n    } else {\n        log::error!("consensus engine channel failed to initialized");\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"get_block",children:(0,s.jsx)(n.code,{children:"get_block"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the block with the given block ID."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'impl subnet::rpc::snowman::block::Getter for Vm {\n    async fn get_block(\n        &self,\n        blk_id: ids::Id,\n    ) -> io::Result<Box<dyn subnet::rpc::consensus::snowman::Block + Send + Sync>> {\n        let vm_state = self.state.read().await;\n        if let Some(state) = &vm_state.state {\n            let block = state.get_block(&blk_id).await?;\n            return Ok(Box::new(block));\n        }\n\n        Err(Error::new(ErrorKind::NotFound, "state manager not found"))\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"propose_block",children:(0,s.jsx)(n.code,{children:"propose_block"})}),"\n",(0,s.jsx)(n.p,{children:"Proposes arbitrary data to mempool and notifies that a block is ready for builds. Other VMs may\noptimize mempool with more complicated batching mechanisms."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'pub async fn propose_block(&self, d: Vec<u8>) -> io::Result<()> {\n    let size = d.len();\n    log::info!("received propose_block of {size} bytes");\n\n    if size > PROPOSE_LIMIT_BYTES {\n        log::info!("limit exceeded... returning an error...");\n        return Err(Error::new(\n            ErrorKind::InvalidInput,\n            format!(\n                "data {}-byte exceeds the limit {}-byte",\n                size, PROPOSE_LIMIT_BYTES\n            ),\n        ));\n    }\n\n    let mut mempool = self.mempool.write().await;\n    mempool.push_back(d);\n    log::info!("proposed {size} bytes of data for a block");\n\n    self.notify_block_ready().await;\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"parse_block",children:(0,s.jsx)(n.code,{children:"parse_block"})}),"\n",(0,s.jsx)(n.p,{children:"Parses a block from its byte representation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:'impl subnet::rpc::snowman::block::Parser for Vm {\n    async fn parse_block(\n        &self,\n        bytes: &[u8],\n    ) -> io::Result<Box<dyn subnet::rpc::consensus::snowman::Block + Send + Sync>> {\n        let vm_state = self.state.read().await;\n        if let Some(state) = &vm_state.state {\n            let mut new_block = Block::from_slice(bytes)?;\n            new_block.set_status(choices::status::Status::Processing);\n            new_block.set_state(state.clone());\n            log::debug!("parsed block {}", new_block.id());\n\n            match state.get_block(&new_block.id()).await {\n                Ok(prev) => {\n                    log::debug!("returning previously parsed block {}", prev.id());\n                    return Ok(Box::new(prev));\n                }\n                Err(_) => return Ok(Box::new(new_block)),\n            };\n        }\n\n        Err(Error::new(ErrorKind::NotFound, "state manager not found"))\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"set_preference",children:(0,s.jsx)(n.code,{children:"set_preference"})}),"\n",(0,s.jsx)(n.p,{children:"Sets the container preference of the VM."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/vm/mod.rs"',children:"pub async fn set_preference(&self, id: ids::Id) -> io::Result<()> {\n    let mut vm_state = self.state.write().await;\n    vm_state.preferred = id;\n\n    Ok(())\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mempool",children:"Mempool"}),"\n",(0,s.jsx)(n.p,{children:"The mempool is a buffer of volatile memory that stores pending transactions. Transactions are stored\nin the mempool whenever a node learns about a new transaction."}),"\n",(0,s.jsxs)(n.p,{children:["The mempool implementation for ",(0,s.jsx)(n.code,{children:"timestampvm-rs"})," is very simple."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:" mempool: Arc::new(RwLock::new(VecDeque::with_capacity(100))),\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By using\n",(0,s.jsx)(n.a,{href:"https://doc.rust-lang.org/std/collections/struct.VecDeque.html",children:"VecDeque"})," we\ncan have better control of element ordering (ex. pop_back(), pop_front())."]}),"\n",(0,s.jsx)(n.h3,{id:"static-api",children:"Static API"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"If this method is called, no other method will be called on this VM. Each registered VM will have a\nsingle instance created to handle static APIs. This instance will be handled separately from\ninstances created to service an instance of a chain."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/api/static_handlers.rs"',children:'#[rpc]\npub trait Rpc {\n    #[rpc(name = "ping", alias("timestampvm.ping"))]\n    fn ping(&self) -> BoxFuture<Result<crate::api::PingResponse>>;\n}\n\n/// Implements API services for the static handlers.\npub struct Service {\n    pub vm: vm::Vm,\n}\n\nimpl Service {\n    pub fn new(vm: vm::Vm) -> Self {\n        Self { vm }\n    }\n}\n\nimpl Rpc for Service {\n    fn ping(&self) -> BoxFuture<Result<crate::api::PingResponse>> {\n        log::debug!("ping called");\n        Box::pin(async move { Ok(crate::api::PingResponse { success: true }) })\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"api",children:"API"}),"\n",(0,s.jsx)(n.p,{children:"Defines RPCs specific to the chain."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="/timestampvm/src/api/chain_handlers.rs"',children:'#[rpc]\npub trait Rpc {\n    /// Pings the VM.\n    #[rpc(name = "ping", alias("timestampvm.ping"))]\n    fn ping(&self) -> BoxFuture<Result<crate::api::PingResponse>>;\n\n    /// Proposes the arbitrary data.\n    #[rpc(name = "proposeBlock", alias("timestampvm.proposeBlock"))]\n    fn propose_block(&self, args: ProposeBlockArgs) -> BoxFuture<Result<ProposeBlockResponse>>;\n\n    /// Fetches the last accepted block.\n    #[rpc(name = "lastAccepted", alias("timestampvm.lastAccepted"))]\n    fn last_accepted(&self) -> BoxFuture<Result<LastAcceptedResponse>>;\n\n    /// Fetches the block.\n    #[rpc(name = "getBlock", alias("timestampvm.getBlock"))]\n    fn get_block(&self, args: GetBlockArgs) -> BoxFuture<Result<GetBlockResponse>>;\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct ProposeBlockArgs {\n    #[serde(with = "lux_types::codec::serde::base64_bytes")]\n    pub data: Vec<u8>,\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct ProposeBlockResponse {\n    pub success: bool,\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct LastAcceptedResponse {\n    pub id: ids::Id,\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct GetBlockArgs {\n    pub id: String,\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct GetBlockResponse {\n    pub block: Block,\n}\n\n/// Implements API services for the chain-specific handlers.\npub struct Service {\n    pub vm: vm::Vm,\n}\n\nimpl Service {\n    pub fn new(vm: vm::Vm) -> Self {\n        Self { vm }\n    }\n}\n\nimpl Rpc for Service {\n    fn ping(&self) -> BoxFuture<Result<crate::api::PingResponse>> {\n        log::debug!("ping called");\n        Box::pin(async move { Ok(crate::api::PingResponse { success: true }) })\n    }\n\n    fn propose_block(&self, args: ProposeBlockArgs) -> BoxFuture<Result<ProposeBlockResponse>> {\n        log::debug!("propose_block called");\n        let vm = self.vm.clone();\n\n        Box::pin(async move {\n            vm.propose_block(args.data)\n                .await\n                .map_err(create_jsonrpc_error)?;\n            Ok(ProposeBlockResponse { success: true })\n        })\n    }\n\n    fn last_accepted(&self) -> BoxFuture<Result<LastAcceptedResponse>> {\n        log::debug!("last accepted method called");\n        let vm = self.vm.clone();\n\n        Box::pin(async move {\n            let vm_state = vm.state.read().await;\n            if let Some(state) = &vm_state.state {\n                let last_accepted = state\n                    .get_last_accepted_block_id()\n                    .await\n                    .map_err(create_jsonrpc_error)?;\n\n                return Ok(LastAcceptedResponse { id: last_accepted });\n            }\n\n            Err(Error {\n                code: ErrorCode::InternalError,\n                message: String::from("no state manager found"),\n                data: None,\n            })\n        })\n    }\n\n    fn get_block(&self, args: GetBlockArgs) -> BoxFuture<Result<GetBlockResponse>> {\n        let blk_id = ids::Id::from_str(&args.id).unwrap();\n        log::info!("get_block called for {}", blk_id);\n\n        let vm = self.vm.clone();\n\n        Box::pin(async move {\n            let vm_state = vm.state.read().await;\n            if let Some(state) = &vm_state.state {\n                let block = state\n                    .get_block(&blk_id)\n                    .await\n                    .map_err(create_jsonrpc_error)?;\n\n                return Ok(GetBlockResponse { block });\n            }\n\n            Err(Error {\n                code: ErrorCode::InternalError,\n                message: String::from("no state manager found"),\n                data: None,\n            })\n        })\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:'Below are examples of API calls, in which "2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7" is\nthe blockchain ID.'}),"\n",(0,s.jsx)(n.h4,{id:"timestampvmgetblock",children:(0,s.jsx)(n.code,{children:"timestampvm.getBlock"})}),"\n",(0,s.jsx)(n.p,{children:"Given a valid block ID, returns a serialized block."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'curl -X POST --data \'{\n    "jsonrpc": "2.0",\n    "id"     : 1,\n    "method" : "timestampvm.getBlock",\n    "params" : [{"id":"SDfFUzkdzWZbJ6YMysPPNEF5dWLp9q35mEMaLa8Ha2w9aMKoC"}]\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/bc/2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7/rpc\n\n# example response\n# {"jsonrpc":"2.0","result":{"block":{"data":"0x32596655705939524358","height":0,"parent_id":"11111111111111111111111111111111LpoYY","timestamp":0}},"id":1}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"timestampvmproposeblock",children:(0,s.jsx)(n.code,{children:"timestampvm.proposeBlock"})}),"\n",(0,s.jsx)(n.p,{children:"Proposes arbitrary data for a new block to consensus."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'# to propose data\necho 1 | base64 | tr -d \\\\n\n# MQo=\n\ncurl -X POST --data \'{\n    "jsonrpc": "2.0",\n    "id"     : 1,\n    "method" : "timestampvm.proposeBlock",\n    "params" : [{"data":"MQo="}]\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/bc/2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7/rpc\n\n# example response\n# {"jsonrpc":"2.0","result":{"success":true},"id":1}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"timestampvmlastaccepted",children:(0,s.jsx)(n.code,{children:"timestampvm.lastAccepted"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the ID of the last accepted block."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'curl -X POST --data \'{\n    "jsonrpc": "2.0",\n    "id"     : 1,\n    "method" : "timestampvm.lastAccepted",\n    "params" : []\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/bc/2wb1UXxAstB8ywwv4rU2rFCjLgXnhT44hbLPbwpQoGvFb2wRR7/rpc\n\n# example response\n# {"jsonrpc":"2.0","result":{"id":"SDfFUzkdzWZbJ6YMysPPNEF5dWLp9q35mEMaLa8Ha2w9aMKoC"},"id":1}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"plugin",children:"Plugin"}),"\n",(0,s.jsxs)(n.p,{children:["In order to make this VM compatible with ",(0,s.jsx)(n.code,{children:"go-plugin"}),", we need to define a ",(0,s.jsx)(n.code,{children:"main"})," package and method,\nwhich serves our VM over gRPC so that Luxd can call its methods."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"main.rs"}),"'s contents are:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="timestampvm/src/bin/timestampvm/main.rs"',children:'async fn main() -> io::Result<()> {\n    let matches = Command::new(APP_NAME)\n        .version(crate_version!())\n        .about("Timestamp Vm")\n        .subcommands(vec![genesis::command(), vm_id::command()])\n        .get_matches();\n\n    // ref. https://github.com/env-logger-rs/env_logger/issues/47\n    env_logger::init_from_env(\n        env_logger::Env::default().filter_or(env_logger::DEFAULT_FILTER_ENV, "info"),\n    );\n\n    match matches.subcommand() {\n        Some((genesis::NAME, sub_matches)) => {\n            let data = sub_matches.get_one::<String>("DATA").expect("required");\n            let genesis = timestampvm::genesis::Genesis { data: data.clone() };\n            println!("{genesis}");\n\n            Ok(())\n        }\n\n        Some((vm_id::NAME, sub_matches)) => {\n            let vm_name = sub_matches.get_one::<String>("VM_NAME").expect("required");\n            let id = subnet::vm_name_to_id(vm_name)?;\n            println!("{id}");\n\n            Ok(())\n        }\n\n        _ => {\n            log::info!("starting timestampvm");\n\n            let (stop_ch_tx, stop_ch_rx): (Sender<()>, Receiver<()>) = broadcast::channel(1);\n            let vm_server = subnet::rpc::vm::server::Server::new(vm::Vm::new(), stop_ch_tx);\n            subnet::rpc::plugin::serve(vm_server, stop_ch_rx).await\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"installing-a-vm",children:"Installing a VM"}),"\n",(0,s.jsxs)(n.p,{children:["Luxd searches for and registers VM plugins under the ",(0,s.jsx)(n.code,{children:"plugins"})," ",(0,s.jsx)(n.a,{href:"/docs/nodes/configure/luxd-config-flags#--plugin-dir-string",children:"directory"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"To install the virtual machine onto your node, you need to move the built virtual machine binary\nunder this directory. Virtual machine executable names must be either a full virtual machine ID\n(encoded in CB58), or a VM alias."}),"\n",(0,s.jsx)(n.p,{children:"Copy the binary into the plugins directory."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cp -n <path to your binary> $GOPATH/src/github.com/luxfi/luxd/build/plugins/\n"})}),"\n",(0,s.jsx)(n.h4,{id:"node-is-not-running",children:"Node Is Not Running"}),"\n",(0,s.jsxs)(n.p,{children:["If your node isn't running yet, you can install all virtual machines under your ",(0,s.jsx)(n.code,{children:"plugin"})," directory\nby starting the node."]}),"\n",(0,s.jsx)(n.h4,{id:"node-is-already-running",children:"Node Is Already Running"}),"\n",(0,s.jsxs)(n.p,{children:["Load the binary with the ",(0,s.jsx)(n.code,{children:"loadVMs"})," API."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -sX POST --data \'{\n    "jsonrpc":"2.0",\n    "id"     :1,\n    "method" :"admin.loadVMs",\n    "params" :{}\n}\' -H \'content-type:application/json;\' 127.0.0.1:9650/ext/admin\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Confirm the response of ",(0,s.jsx)(n.code,{children:"loadVMs"})," contains the newly installed virtual machine\n",(0,s.jsx)(n.code,{children:"tGas3T58KzdjcJ32c6GpePhtqo9rrHJ1oR9wFBtCcMgaosthX"}),". You'll see this virtual machine as well as any\nothers that weren't already installed previously in the response."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "jsonrpc": "2.0",\n  "result": {\n    "newVMs": {\n      "tGas3T58KzdjcJ32c6GpePhtqo9rrHJ1oR9wFBtCcMgaosthX": [\n        "timestampvm-rs",\n        "timestamp-rs"\n      ],\n      "spdxUxVJQbX85MGxMHbKw1sHxMnSqJ3QBzDyDYEP3h6TLuxqQ": []\n    }\n  },\n  "id": 1\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now, this VM's static API can be accessed at endpoints ",(0,s.jsx)(n.code,{children:"/ext/vm/timestampvm-rs"})," and\n",(0,s.jsx)(n.code,{children:"/ext/vm/timestamp-rs"}),". For more details about VM configs, see\n",(0,s.jsx)(n.a,{href:"/docs/nodes/configure/luxd-config-flags#vm-configs",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In this tutorial, we used the VM's ID as the executable name to simplify the process. However,\nLuxd would also accept ",(0,s.jsx)(n.code,{children:"timestampvm-rs"})," or ",(0,s.jsx)(n.code,{children:"timestamp-rs"})," since those are registered aliases\nin previous step."]}),"\n",(0,s.jsx)(n.h2,{id:"wrapping-up",children:"Wrapping Up"}),"\n",(0,s.jsx)(n.p,{children:"That\u2019s it! That\u2019s the entire implementation of a VM which defines a blockchain-based timestamp\nserver written in Rust!"}),"\n",(0,s.jsx)(n.p,{children:"In this tutorial, we learned:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"block::ChainVM"})," trait, which all VMs that define a linear chain must implement"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"snowman::Block"})," trait, which all blocks that are part of a linear chain must implement"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"subnet"})," mod, which allows blockchains to run in their own processes using the ",(0,s.jsx)(n.code,{children:"rpcchainvm"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["An actual implementation of ",(0,s.jsx)(n.code,{children:"block::ChainVM"})," and ",(0,s.jsx)(n.code,{children:"snowman::Block"}),"."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},43540:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(48318);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);
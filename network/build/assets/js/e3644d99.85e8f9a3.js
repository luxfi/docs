"use strict";(self.webpackChunk_luxdocs_network=self.webpackChunk_luxdocs_network||[]).push([[3367],{55463:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=t(49214),s=t(43540);const r={tags:["Build","Virtual Machines"],description:"Learn how to build a complex virtual machine on Lux using Golang.",sidebar_label:"Complex Golang VM",pagination_label:"Build a Complex Golang VM",sidebar_position:2},l="How to Build a Complex Golang VM",o={id:"build/vm/create/golang-vm-complex",title:"How to Build a Complex Golang VM",description:"Learn how to build a complex virtual machine on Lux using Golang.",source:"@site/docs/build/vm/create/golang-vm-complex.md",sourceDirName:"build/vm/create",slug:"/build/vm/create/golang-vm-complex",permalink:"/docs/build/vm/create/golang-vm-complex",draft:!1,unlisted:!1,editUrl:"https://github.com/luxfi/docs/edit/main/docs/build/vm/create/golang-vm-complex.md",tags:[{label:"Build",permalink:"/docs/tags/build"},{label:"Virtual Machines",permalink:"/docs/tags/virtual-machines"}],version:"current",sidebarPosition:2,frontMatter:{tags:["Build","Virtual Machines"],description:"Learn how to build a complex virtual machine on Lux using Golang.",sidebar_label:"Complex Golang VM",pagination_label:"Build a Complex Golang VM",sidebar_position:2},sidebar:"build-vm",previous:{title:"Build a Simple Golang VM",permalink:"/docs/build/vm/create/golang-vm-simple"},next:{title:"Build a Rust VM",permalink:"/docs/build/vm/create/rust-vm"}},a={},c=[{value:"Components",id:"components",level:2},{value:"Lifecycle of a Transaction",id:"lifecycle-of-a-transaction",level:2},{value:"Coding the Virtual Machine",id:"coding-the-virtual-machine",level:2},{value:"Transactions",id:"transactions",level:3},{value:"UnsignedTransaction",id:"unsignedtransaction",level:4},{value:"BaseTx",id:"basetx",level:4},{value:"TransferTx",id:"transfertx",level:4},{value:"SetTx",id:"settx",level:4},{value:"Signed Transaction",id:"signed-transaction",level:4},{value:"Example",id:"example",level:5},{value:"Mempool",id:"mempool",level:3},{value:"Mempool Overview",id:"mempool-overview",level:4},{value:"Mempool Methods",id:"mempool-methods",level:4},{value:"Add",id:"add",level:4},{value:"Block Builder",id:"block-builder",level:3},{value:"Block Builder Overview",id:"block-builder-overview",level:4},{value:"Block Builder Methods",id:"block-builder-methods",level:4},{value:"Gossip",id:"gossip",level:4},{value:"Build",id:"build",level:4},{value:"Network",id:"network",level:3},{value:"Network Methods",id:"network-methods",level:4},{value:"GossipNewTxs",id:"gossipnewtxs",level:5},{value:"Block",id:"block",level:3},{value:"StatefulBlock",id:"statefulblock",level:4},{value:"StatelessBlock",id:"statelessblock",level:4},{value:"API",id:"api",level:3},{value:"Virtual Machine",id:"virtual-machine",level:3},{value:"Virtual Machine Methods",id:"virtual-machine-methods",level:4},{value:"Initialize",id:"initialize",level:5},{value:"GetBlock",id:"getblock",level:5},{value:"ParseBlock",id:"parseblock",level:5},{value:"BuildBlock",id:"buildblock",level:5},{value:"SetPreference",id:"setpreference",level:5},{value:"LastAccepted",id:"lastaccepted",level:5},{value:"CLI",id:"cli",level:3},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"how-to-build-a-complex-golang-vm",children:"How to Build a Complex Golang VM"}),"\n",(0,i.jsxs)(n.p,{children:["In this tutorial, we'll walk through how to build a virtual machine by referencing\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm",children:"the BlobVM"}),". The BlobVM is a virtual machine that can be used\nto implement a decentralized key-value store."]}),"\n",(0,i.jsx)(n.p,{children:'A blob (shorthand for "binary large object") is an arbitrary piece of data. BlobVM stores a key-value\npair by breaking it apart into multiple chunks stored with their hashes as their keys in the blockchain.\nA root key-value pair has references to these chunks for lookups. By default, the maximum chunk size\nis set to 200 KiB.'}),"\n",(0,i.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,i.jsx)(n.p,{children:"A VM defines how a blockchain should be built. A block is populated with a set of transactions which\nmutate the state of the blockchain when executed. When a block with a set of transactions is applied\nto a given state, a state transition occurs by executing all of the transactions in the block in-order\nand applying it to the previous block of the blockchain. By executing a series of blocks\nchronologically, anyone can verify and reconstruct the state of the blockchain at an arbitrary point\nin time."}),"\n",(0,i.jsx)(n.p,{children:"The BlobVM repository has a few components to handle the lifecycle of tasks from a transaction being\nissued to a block being accepted across the network:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transaction"})," - A state transition"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mempool"})," - Stores pending transactions that haven't been finalized yet"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Network"})," - Propagates transactions from the mempool other nodes in the network"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Block"})," - Defines the block format, how to verify it, and how it should be accepted or rejected\nacross the network"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Block Builder"})," - Builds blocks by including transactions from the mempool"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Virtual Machine"})," - Application-level logic. Implements the VM interface needed to interact with\nLux consensus and defines the blueprint for the blockchain."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service"})," - Exposes APIs so users can interact with the VM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Factory"})," - Used to initialize the VM"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"lifecycle-of-a-transaction",children:"Lifecycle of a Transaction"}),"\n",(0,i.jsx)(n.p,{children:"A VM will often times expose a set of APIs so users can interact with the it. In the blockchain,\nblocks can contain a set of transactions which mutate the blockchain's state. Let's dive into the\nlifecycle of a transaction from its issuance to its finalization on the blockchain."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A user makes an API request to ",(0,i.jsx)(n.code,{children:"service.IssueRawTx"})," to issue their transaction","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"This API will deserialize the user's transaction and forward it to the VM"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The transaction is submitted to the VM","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The transaction is added to the VM's mempool"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"The VM asynchronously periodically gossips new transactions in its mempool to other nodes in the\nnetwork so they can learn about them"}),"\n",(0,i.jsx)(n.li,{children:"The VM sends the Lux consensus engine a message to indicate that it has transactions in the\nmempool that are ready to be built into a block"}),"\n",(0,i.jsx)(n.li,{children:"The VM proposes the block with to consensus"}),"\n",(0,i.jsx)(n.li,{children:"Consensus verifies that the block is valid and well-formed"}),"\n",(0,i.jsxs)(n.li,{children:["Consensus gets the network to vote on whether the block should be accepted or rejected","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If a block is rejected, its transactions are reclaimed by the mempool so they can be included in\na future block"}),"\n",(0,i.jsx)(n.li,{children:"If a block is accepted, it's finalized by writing it to the blockchain"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"coding-the-virtual-machine",children:"Coding the Virtual Machine"}),"\n",(0,i.jsx)(n.p,{children:"We'll dive into a few of the packages that are in the The BlobVM repository to learn more about how\nthey work:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/tree/master/vm",children:(0,i.jsx)(n.code,{children:"vm"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"block_builder.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"chain_vm.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"network.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"service.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"vm.go"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/tree/master/chain",children:(0,i.jsx)(n.code,{children:"chain"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"unsigned_tx.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"base_tx.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"transfer_tx.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"set_tx.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"tx.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"block.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"mempool.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"storage.go"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"builder.go"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/tree/master/mempool",children:(0,i.jsx)(n.code,{children:"mempool"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"mempool.go"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactions",children:"Transactions"}),"\n",(0,i.jsx)(n.p,{children:"The state the blockchain can only be mutated by getting the network to accept a signed transaction.\nA signed transaction contains the transaction to be executed alongside the signature of the issuer.\nThe signature is required to cryptographically verify the sender's identity. A VM can define an\narbitrary amount of unique transactions types to support different operations on the blockchain. The\nBlobVM implements two different transactions types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/transfer_tx.go",children:"TransferTx"})," - Transfers coins\nbetween accounts."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/set_tx.go",children:"SetTx"})," - Stores a key-value pair\non the blockchain."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"unsignedtransaction",children:"UnsignedTransaction"}),"\n",(0,i.jsxs)(n.p,{children:["All transactions in the BlobVM implement the common\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/unsigned_tx.go",children:(0,i.jsx)(n.code,{children:"UnsignedTransaction"})}),"\ninterface, which exposes shared functionality for all transaction types."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type UnsignedTransaction interface {\n\tCopy() UnsignedTransaction\n\tGetBlockID() ids.ID\n\tGetMagic() uint64\n\tGetPrice() uint64\n\tSetBlockID(ids.ID)\n\tSetMagic(uint64)\n\tSetPrice(uint64)\n\tFeeUnits(*Genesis) uint64  // number of units to mine tx\n\tLoadUnits(*Genesis) uint64 // units that should impact fee rate\n\n\tExecuteBase(*Genesis) error\n\tExecute(*TransactionContext) error\n\tTypedData() *tdata.TypedData\n\tActivity() *Activity\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"basetx",children:"BaseTx"}),"\n",(0,i.jsxs)(n.p,{children:["Common functionality and metadata for transaction types are implemented by ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go",children:(0,i.jsx)(n.code,{children:"BaseTx"})}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L26",children:(0,i.jsx)(n.code,{children:"SetBlockID"})})," sets the\ntransaction's block ID."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L22",children:(0,i.jsx)(n.code,{children:"GetBlockID"})})," returns the\ntransaction's block ID."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L34",children:(0,i.jsx)(n.code,{children:"SetMagic"})})," sets the magic\nnumber. The magic number is used to differentiate chains to prevent replay attacks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L30",children:(0,i.jsx)(n.code,{children:"GetMagic"})})," returns the magic\nnumber. Magic number is defined in genesis."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L42",children:(0,i.jsx)(n.code,{children:"SetPrice"})})," sets the price\nper fee unit for this transaction."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L38",children:(0,i.jsx)(n.code,{children:"GetPrice"})})," returns the price\nfor this transaction."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L59",children:(0,i.jsx)(n.code,{children:"FeeUnits"})})," returns the fee\nunits this transaction will consume."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L63",children:(0,i.jsx)(n.code,{children:"LoadUnits"})})," identical to ",(0,i.jsx)(n.code,{children:"FeeUnits"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/base_tx.go#L46",children:(0,i.jsx)(n.code,{children:"ExecuteBase"})})," executes\ncommon validation checks across different transaction types. This validates the transaction contains\na valid block ID, magic number, and gas price as defined by genesis."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"transfertx",children:"TransferTx"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/transfer_tx.go#L16",children:(0,i.jsx)(n.code,{children:"TransferTx"})})," supports the\ntransfer of tokens from one account to another."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type TransferTx struct {\n\t*BaseTx `serialize:"true" json:"baseTx"`\n\n\t// To is the recipient of the [Units].\n\tTo common.Address `serialize:"true" json:"to"`\n\n\t// Units are transferred to [To].\n\tUnits uint64 `serialize:"true" json:"units"`\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TransferTx"})," embeds ",(0,i.jsx)(n.code,{children:"BaseTx"})," to avoid re-implementing common operations with other transactions, but\nimplements its own ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/transfer_tx.go#L26",children:(0,i.jsx)(n.code,{children:"Execute"})}),"\nto support token transfers."]}),"\n",(0,i.jsx)(n.p,{children:"This performs a few checks to ensure that the transfer is valid before transferring the tokens\nbetween the two accounts."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (t *TransferTx) Execute(c *TransactionContext) error {\n\t// Must transfer to someone\n\tif bytes.Equal(t.To[:], zeroAddress[:]) {\n\t\treturn ErrNonActionable\n\t}\n\n\t// This prevents someone from transferring to themselves.\n\tif bytes.Equal(t.To[:], c.Sender[:]) {\n\t\treturn ErrNonActionable\n\t}\n\tif t.Units == 0 {\n\t\treturn ErrNonActionable\n\t}\n\tif _, err := ModifyBalance(c.Database, c.Sender, false, t.Units); err != nil {\n\t\treturn err\n\t}\n\tif _, err := ModifyBalance(c.Database, t.To, true, t.Units); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"settx",children:"SetTx"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SetTx"})," is used to assign a value to a key."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type SetTx struct {\n\t*BaseTx `serialize:"true" json:"baseTx"`\n\n\tValue []byte `serialize:"true" json:"value"`\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SetTx"})," implements its own\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/set_tx.go#L48",children:(0,i.jsx)(n.code,{children:"FeeUnits"})})," method to\ncompensate the network according to the size of the blob being stored."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (s *SetTx) FeeUnits(g *Genesis) uint64 {\n\t// We don't subtract by 1 here because we want to charge extra for any\n\t// value-based interaction (even if it is small or a delete).\n\treturn s.BaseTx.FeeUnits(g) + valueUnits(g, uint64(len(s.Value)))\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SetTx"}),"'s ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/set_tx.go#L21",children:(0,i.jsx)(n.code,{children:"Execute"})})," method\nperforms a few safety checks to validate that the blob meets the size constraints enforced by\ngenesis and doesn't overwrite an existing key before writing it to the blockchain."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (s *SetTx) Execute(t *TransactionContext) error {\n\tg := t.Genesis\n\tswitch {\n\tcase len(s.Value) == 0:\n\t\treturn ErrValueEmpty\n\tcase uint64(len(s.Value)) > g.MaxValueSize:\n\t\treturn ErrValueTooBig\n\t}\n\n\tk := ValueHash(s.Value)\n\n\t// Do not allow duplicate value setting\n\t_, exists, err := GetValueMeta(t.Database, k)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif exists {\n\t\treturn ErrKeyExists\n\t}\n\n\treturn PutKey(t.Database, k, &ValueMeta{\n\t\tSize:    uint64(len(s.Value)),\n\t\tTxID:    t.TxID,\n\t\tCreated: t.BlockTime,\n\t})\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"signed-transaction",children:"Signed Transaction"}),"\n",(0,i.jsxs)(n.p,{children:["The unsigned transactions mentioned previously can't be issued to the network without first being\nsigned. BlobVM implements signed transactions by embedding the unsigned transaction alongside its\nsignature in ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/tx.go",children:(0,i.jsx)(n.code,{children:"Transaction"})}),". In BlobVM,\na signature is defined as the\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wikiElliptic_Curve_Digital_Signature_Algorithm",children:"ECDSA signature"})," of the\nissuer's private key of the ",(0,i.jsx)(n.a,{href:"https://keccak.team/keccak.html",children:"KECCAK256"})," hash of the unsigned\ntransaction's data (",(0,i.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-712",children:"digest hash"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type Transaction struct {\n\tUnsignedTransaction `serialize:"true" json:"unsignedTransaction"`\n\tSignature           []byte `serialize:"true" json:"signature"`\n\n\tdigestHash []byte\n\tbytes      []byte\n\tid         ids.ID\n\tsize       uint64\n\tsender     common.Address\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Transaction"})," type wraps any unsigned transaction. When a ",(0,i.jsx)(n.code,{children:"Transaction"})," is executed, it calls the\n",(0,i.jsx)(n.code,{children:"Execute"})," method of the underlying embedded ",(0,i.jsx)(n.code,{children:"UnsignedTx"})," and performs the following sanity checks:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The underlying ",(0,i.jsx)(n.code,{children:"UnsignedTx"})," must meet the requirements set by genesis","\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"This includes checks to make sure that the transaction contains the correct magic number and\nmeets the minimum gas price as defined by genesis"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"The transaction's block ID must be a recently accepted block"}),"\n",(0,i.jsx)(n.li,{children:"The transaction must not be a recently issued transaction"}),"\n",(0,i.jsx)(n.li,{children:"The issuer of the transaction must have enough gas"}),"\n",(0,i.jsx)(n.li,{children:"The transaction's gas price must be meet the next expected block's minimum gas price"}),"\n",(0,i.jsx)(n.li,{children:"The transaction must execute without error"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the transaction is successfully verified, it's submitted as a pending write to the blockchain."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (t *Transaction) Execute(g *Genesis, db database.Database, blk *StatelessBlock, context *Context) error {\n\tif err := t.UnsignedTransaction.ExecuteBase(g); err != nil {\n\t\treturn err\n\t}\n\tif !context.RecentBlockIDs.Contains(t.GetBlockID()) {\n\t\t// Hash must be recent to be any good\n\t\t// Should not happen beause of mempool cleanup\n\t\treturn ErrInvalidBlockID\n\t}\n\tif context.RecentTxIDs.Contains(t.ID()) {\n\t\t// Tx hash must not be recently executed (otherwise could be replayed)\n\t\t//\n\t\t// NOTE: We only need to keep cached tx hashes around as long as the\n\t\t// block hash referenced in the tx is valid\n\t\treturn ErrDuplicateTx\n\t}\n\n\t// Ensure sender has balance\n\tif _, err := ModifyBalance(db, t.sender, false, t.FeeUnits(g)*t.GetPrice()); err != nil {\n\t\treturn err\n\t}\n\tif t.GetPrice() < context.NextPrice {\n\t\treturn ErrInsufficientPrice\n\t}\n\tif err := t.UnsignedTransaction.Execute(&TransactionContext{\n\t\tGenesis:   g,\n\t\tDatabase:  db,\n\t\tBlockTime: uint64(blk.Tmstmp),\n\t\tTxID:      t.id,\n\t\tSender:    t.sender,\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := SetTransaction(db, t); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["Let's walk through an example on how to issue a ",(0,i.jsx)(n.code,{children:"SetTx"})," transaction to the BlobVM to write a key-value\npair."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Create the unsigned transaction for ",(0,i.jsx)(n.code,{children:"SetTx"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'utx := &chain.SetTx{\n    BaseTx: &chain.BaseTx{},\n    Value:  []byte("data"),\n}\n\nutx.SetBlockID(lastAcceptedID)\nutx.SetMagic(genesis.Magic)\nutx.SetPrice(price + blockCost/utx.FeeUnits(genesis))\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Calculate the ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/tx.go#L41",children:"digest hash"})," for\nthe transaction."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"digest, err := chain.DigestHash(utx)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/crypto.go#L17",children:"Sign"})," the digest hash with\nthe issuer's private key."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"signature, err := chain.Sign(digest, privateKey)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create and initialize the new signed transaction."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"tx := chain.NewTx(utx, sig)\nif err := tx.Init(g); err != nil {\n    return ids.Empty, 0, err\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Issue the request with the client"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"txID, err = cli.IssueRawTx(ctx, tx.Bytes())\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mempool",children:"Mempool"}),"\n",(0,i.jsx)(n.h4,{id:"mempool-overview",children:"Mempool Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/mempool/mempool.go",children:"mempool"})," is a buffer of\nvolatile memory that stores pending transactions. Transactions are stored in the mempool whenever a\nnode learns about a new transaction either through gossip with other nodes or through an API call\nissued by a user."]}),"\n",(0,i.jsxs)(n.p,{children:["The mempool is implemented as a min-max ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Heap_(data_structure)",children:"heap"}),"\nordered by each transaction's gas price. The mempool is created during the\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L151",children:"initialization"})," of VM."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"vm.mempool = mempool.New(vm.genesis, vm.config.MempoolSize)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Whenever a transaction is submitted to VM, it first gets initialized, verified, and executed locally.\nIf the transaction looks valid, then it's added to the\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L431",children:"mempool"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"vm.mempool.Add(tx)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"mempool-methods",children:"Mempool Methods"}),"\n",(0,i.jsx)(n.h4,{id:"add",children:"Add"}),"\n",(0,i.jsxs)(n.p,{children:["When a transaction is added to the mempool,\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/mempool/mempool.go#L43",children:(0,i.jsx)(n.code,{children:"Add"})})," is called. This\nperforms the following:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Checks if the transaction being added already exists in the mempool or not"}),"\n",(0,i.jsx)(n.li,{children:"The transaction is added to the min-max heap"}),"\n",(0,i.jsx)(n.li,{children:"If the mempool's heap size is larger than the maximum configured value, then the lowest paying\ntransaction is evicted"}),"\n",(0,i.jsx)(n.li,{children:"The transaction is added to the list of transactions that are able to be gossiped to other peers"}),"\n",(0,i.jsxs)(n.li,{children:["A notification is sent through the in the ",(0,i.jsx)(n.code,{children:"mempool.Pending"})," channel to indicate that the consensus\nengine should build a new block"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"block-builder",children:"Block Builder"}),"\n",(0,i.jsx)(n.h4,{id:"block-builder-overview",children:"Block Builder Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/block_builder.go",children:(0,i.jsx)(n.code,{children:"TimeBuilder"})}),"\nimplementation for ",(0,i.jsx)(n.code,{children:"BlockBuilder"})," acts as an intermediary notification service between the mempool\nand the consensus engine. It serves the following functions:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Periodically gossips new transactions to other nodes in the network"}),"\n",(0,i.jsx)(n.li,{children:"Periodically notifies the consensus engine that new transactions from the mempool are ready to be\nbuilt into blocks"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TimeBuilder"})," and can exist in 3 states:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dontBuild"})," - There are no transactions in the mempool that are ready to be included in a block"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"building"})," - The consensus engine has been notified that it should build a block and there are\ncurrently transactions in the mempool that are eligible to be included into a block"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mayBuild"})," - There are transactions in the mempool that are eligible to be included into a block,\nbut the consensus engine has not been notified yet"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"block-builder-methods",children:"Block Builder Methods"}),"\n",(0,i.jsx)(n.h4,{id:"gossip",children:"Gossip"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/block_builder.go#L183",children:(0,i.jsx)(n.code,{children:"Gossip"})})," method\ninitiates the gossip of new transactions from the mempool at periodically as defined by ",(0,i.jsx)(n.code,{children:"vm.config.GossipInterval"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"build",children:"Build"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/block_builder.go#L166",children:(0,i.jsx)(n.code,{children:"Build"})})," method\nconsumes transactions from the mempool and signals the consensus engine when it's ready to build a block."]}),"\n",(0,i.jsxs)(n.p,{children:["If the mempool signals the ",(0,i.jsx)(n.code,{children:"TimeBuilder"})," that it has available transactions, ",(0,i.jsx)(n.code,{children:"TimeBuilder"})," will\nsignal consensus that the VM is ready to build a block by sending the consensus engine a\n",(0,i.jsx)(n.code,{children:"common.PendingTxs"})," message."]}),"\n",(0,i.jsxs)(n.p,{children:["When the consensus engine receives the ",(0,i.jsx)(n.code,{children:"common.PendingTxs"})," message it calls the VM's ",(0,i.jsx)(n.code,{children:"BuildBlock"}),"\nmethod. The VM will then build a block from eligible transactions in the mempool."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If there are still remaining transactions in the mempool after a block is built, then the\n",(0,i.jsx)(n.code,{children:"TimeBuilder"})," is put into the ",(0,i.jsx)(n.code,{children:"mayBuild"})," state to indicate that there are still transactions that\nare eligible to be built into block, but the consensus engine isn't aware of it yet."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"network",children:"Network"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/network.go",children:"Network"})," handles the workflow of\ngossiping transactions from a node's mempool to other nodes in the network."]}),"\n",(0,i.jsx)(n.h4,{id:"network-methods",children:"Network Methods"}),"\n",(0,i.jsx)(n.h5,{id:"gossipnewtxs",children:"GossipNewTxs"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GossipNewTxs"})," sends a list of transactions to other nodes in the network. ",(0,i.jsx)(n.code,{children:"TimeBuilder"})," calls the\nnetwork's ",(0,i.jsx)(n.code,{children:"GossipNewTxs"})," function to gossip new transactions in the mempool."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (n *PushNetwork) GossipNewTxs(newTxs []*chain.Transaction) error {\n\ttxs := []*chain.Transaction{}\n\t// Gossip at most the target units of a block at once\n\tfor _, tx := range newTxs {\n\t\tif _, exists := n.gossipedTxs.Get(tx.ID()); exists {\n\t\t\tlog.Debug("already gossiped, skipping", "txId", tx.ID())\n\t\t\tcontinue\n\t\t}\n\t\tn.gossipedTxs.Put(tx.ID(), nil)\n\t\ttxs = append(txs, tx)\n\t}\n\n\treturn n.sendTxs(txs)\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Recently gossiped transactions are maintained in a cache to avoid DDoSing a node from repeated\ngossip failures."}),"\n",(0,i.jsxs)(n.p,{children:["Other nodes in the network will receive the gossiped transactions through their ",(0,i.jsx)(n.code,{children:"AppGossip"})," handler.\nOnce a gossip message is received, it's deserialized and the new transactions are submitted to the VM."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (vm *VM) AppGossip(nodeID ids.NodeID, msg []byte) error {\n\ttxs := make([]*chain.Transaction, 0)\n\tif _, err := chain.Unmarshal(msg, &txs); err != nil {\n\t\treturn nil\n\t}\n\n\t// submit incoming gossip\n\tlog.Debug("AppGossip transactions are being submitted", "txs", len(txs))\n\tif errs := vm.Submit(txs...); len(errs) > 0 {\n\t\tfor _, err := range errs {\n\n\t\t}\n\t}\n\n\treturn nil\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"block",children:"Block"}),"\n",(0,i.jsx)(n.p,{children:"Blocks go through a lifecycle of being proposed by a validator, verified, and decided by consensus.\nUpon acceptance, a block will be committed and will be finalized on the blockchain."}),"\n",(0,i.jsxs)(n.p,{children:["BlobVM implements two types of blocks, ",(0,i.jsx)(n.code,{children:"StatefulBlock"})," and ",(0,i.jsx)(n.code,{children:"StatelessBlock"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"statefulblock",children:"StatefulBlock"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/block.go#L26",children:(0,i.jsx)(n.code,{children:"StatefulBlock"})})," contains\nstrictly the metadata about the block that needs to be written to the database."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type StatefulBlock struct {\n\tPrnt        ids.ID         `serialize:"true" json:"parent"`\n\tTmstmp      int64          `serialize:"true" json:"timestamp"`\n\tHght        uint64         `serialize:"true" json:"height"`\n\tPrice       uint64         `serialize:"true" json:"price"`\n\tCost        uint64         `serialize:"true" json:"cost"`\n\tAccessProof common.Hash    `serialize:"true" json:"accessProof"`\n\tTxs         []*Transaction `serialize:"true" json:"txs"`\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"statelessblock",children:"StatelessBlock"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/block.go#L39",children:"StatelessBlock"})," is a superset of\n",(0,i.jsx)(n.code,{children:"StatefulBlock"})," and additionally contains fields that are needed to support block-level operations\nlike verification and acceptance throughout its lifecycle in the VM."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type StatelessBlock struct {\n\t*StatefulBlock   `serialize:"true" json:"block"`\n\tid                ids.ID\n\tst                choices.Status\n\tt                 time.Time\n\tbytes             []byte\n\tvm                VM\n\tchildren          []*StatelessBlock\n\tonAcceptDB        *versiondb.Database\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Let's have a look at the fields of StatelessBlock:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"StatefulBlock"})," - The metadata about the block that will be written to the database upon acceptance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"bytes"})," - The serialized form of the ",(0,i.jsx)(n.code,{children:"StatefulBlock"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"id"})," - The Keccak256 hash of ",(0,i.jsx)(n.code,{children:"bytes"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"st"})," - The status of the block in consensus (i.e ",(0,i.jsx)(n.code,{children:"Processing"}),", ",(0,i.jsx)(n.code,{children:"Accepted"}),", or ",(0,i.jsx)(n.code,{children:"Rejected"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"children"})," - The children of this block"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onAcceptDB"})," - The database this block should be written to upon acceptance."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When the consensus engine tries to build a block by calling the VM's ",(0,i.jsx)(n.code,{children:"BuildBlock"}),", the VM calls the\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/block.go#L52",children:(0,i.jsx)(n.code,{children:"block.NewBlock"})})," function to\nget a new block that is a child of the currently preferred block."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func NewBlock(vm VM, parent snowman.Block, tmstp int64, context *Context) *StatelessBlock {\n    return &StatelessBlock{\n        StatefulBlock: &StatefulBlock{\n            Tmstmp: tmstp,\n            Prnt:   parent.ID(),\n            Hght:   parent.Height() + 1,\n            Price:  context.NextPrice,\n            Cost:   context.NextCost,\n        },\n        vm: vm,\n        st: choices.Processing,\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Some ",(0,i.jsx)(n.code,{children:"StatelessBlock"})," fields like the block ID, byte representation, and timestamp aren't populated\nimmediately. These are set during the ",(0,i.jsx)(n.code,{children:"StatelessBlock"}),"'s\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/block.go#L112",children:(0,i.jsx)(n.code,{children:"init"})})," method, which\ninitializes these fields once the block has been populated with transactions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (b *StatelessBlock) init() error {\n\tbytes, err := Marshal(b.StatefulBlock)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.bytes = bytes\n\n\tid, err := ids.ToID(crypto.Keccak256(b.bytes))\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.id = id\n\tb.t = time.Unix(b.StatefulBlock.Tmstmp, 0)\n\tg := b.vm.Genesis()\n\tfor _, tx := range b.StatefulBlock.Txs {\n\t\tif err := tx.Init(g); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To build the block, the VM will try to remove as many of the highest-paying transactions from the\nmempool to include them in the new block until the maximum block fee set by genesis is reached."}),"\n",(0,i.jsx)(n.p,{children:"A block once built, can exist in two states:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Rejected - The block was not accepted by consensus","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In this case, the mempool will reclaim the rejected block's transactions so they can be included\nin a future block."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Accepted - The block was accepted by consensus","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In this case, we write the block to the blockchain by committing it to the database."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When the consensus engine receives the built block, it calls the block's\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/chain/block.go#L227",children:(0,i.jsx)(n.code,{children:"Verify"})})," method to validate\nthat the block is well-formed. In BlobVM, the following constraints are placed on valid blocks:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A block must contain at least one transaction and the block's timestamp must be within 10s into\nthe future."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"if len(b.Txs) == 0 {\n  return nil, nil, ErrNoTxs\n}\nif b.Timestamp().Unix() >= time.Now().Add(futureBound).Unix() {\n  return nil, nil, ErrTimestampTooLate\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The sum of the gas units consumed by the transactions in the block must not exceed the gas limit\ndefined by genesis."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"blockSize := uint64(0)\nfor _, tx := range b.Txs {\n  blockSize += tx.LoadUnits(g)\n  if blockSize > g.MaxBlockSize {\n    return nil, nil, ErrBlockTooBig\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The parent block of the proposed block must exist and have an earlier timestamp."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'parent, err := b.vm.GetStatelessBlock(b.Prnt)\nif err != nil {\n  log.Debug("could not get parent", "id", b.Prnt)\n  return nil, nil, err\n}\nif b.Timestamp().Unix() < parent.Timestamp().Unix() {\n  return nil, nil, ErrTimestampTooEarly\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The target block price and minimum gas price must meet the minimum enforced by the VM."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"context, err := b.vm.ExecutionContext(b.Tmstmp, parent)\nif err != nil {\n  return nil, nil, err\n}\nif b.Cost != context.NextCost {\n  return nil, nil, ErrInvalidCost\n}\nif b.Price != context.NextPrice {\n  return nil, nil, ErrInvalidPrice\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"After the results of consensus are complete, the block is either accepted by committing the block to\nthe database or rejected by returning the block's transactions into the mempool."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// implements "snowman.Block.choices.Decidable"\nfunc (b *StatelessBlock) Accept() error {\n\tif err := b.onAcceptDB.Commit(); err != nil {\n\t\treturn err\n\t}\n\tfor _, child := range b.children {\n\t\tif err := child.onAcceptDB.SetDatabase(b.vm.State()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tb.st = choices.Accepted\n\tb.vm.Accepted(b)\n\treturn nil\n}\n\n// implements "snowman.Block.choices.Decidable"\nfunc (b *StatelessBlock) Reject() error {\n\tb.st = choices.Rejected\n\tb.vm.Rejected(b)\n\treturn nil\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"api",children:"API"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/public_service.go",children:"Service"})," implements an API\nserver so users can interact with the VM. The VM implements the interface method\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L265",children:(0,i.jsx)(n.code,{children:"CreateHandlers"})})," that exposes the\nVM's RPC API."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (vm *VM) CreateHandlers() (map[string]*common.HTTPHandler, error) {\n    apis := map[string]*common.HTTPHandler{}\n    public, err := newHandler(Name, &PublicService{vm: vm})\n    if err != nil {\n        return nil, err\n    }\n    apis[PublicEndpoint] = public\n    return apis, nil\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["One API that's exposed is\n",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/public_service.go#L63",children:(0,i.jsx)(n.code,{children:"IssueRawTx"})})," to allow\nusers to issue transactions to the BlobVM. It accepts an ",(0,i.jsx)(n.code,{children:"IssueRawTxArgs"})," that contains the\ntransaction the user wants to issue and forwards it to the VM."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (svc *PublicService) IssueRawTx(_ *http.Request, args *IssueRawTxArgs, reply *IssueRawTxReply) error {\n\ttx := new(chain.Transaction)\n\tif _, err := chain.Unmarshal(args.Tx, tx); err != nil {\n\t\treturn err\n\t}\n\n\t// otherwise, unexported tx.id field is empty\n\tif err := tx.Init(svc.vm.genesis); err != nil {\n\t\treturn err\n\t}\n\treply.TxID = tx.ID()\n\n\terrs := svc.vm.Submit(tx)\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\tif len(errs) == 1 {\n\t\treturn errs[0]\n\t}\n\treturn fmt.Errorf("%v", errs)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"virtual-machine",children:"Virtual Machine"}),"\n",(0,i.jsxs)(n.p,{children:["We have learned about all the components used in the BlobVM. Most of these components are referenced\nin the ",(0,i.jsx)(n.code,{children:"vm.go"})," file, which acts as the entry point for the consensus engine as well as users\ninteracting with the blockchain. For example, the engine calls ",(0,i.jsx)(n.code,{children:"vm.BuildBlock()"}),", that in turn calls\n",(0,i.jsx)(n.code,{children:"chain.BuildBlock()"}),". Another example is when a user issues a raw transaction through service APIs,\nthe ",(0,i.jsx)(n.code,{children:"vm.Submit()"})," method is called."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at some of the important methods of ",(0,i.jsx)(n.code,{children:"vm.go"})," that must be implemented:"]}),"\n",(0,i.jsx)(n.h4,{id:"virtual-machine-methods",children:"Virtual Machine Methods"}),"\n",(0,i.jsx)(n.h5,{id:"initialize",children:"Initialize"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L92",children:"Initialize"})," is invoked by ",(0,i.jsx)(n.code,{children:"luxd"}),"\nwhen creating the blockchain. ",(0,i.jsx)(n.code,{children:"luxd"})," passes some parameters to the implementing VM."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ctx"})," - Metadata about the VM's execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dbManager"})," - The database that the VM can write to"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"genesisBytes"})," - The serialized representation of the genesis state of this VM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"upgradeBytes"})," - The serialized representation of network upgrades"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"configBytes"})," - The serialized VM-specific ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/config.go#L10",children:"configuration"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"toEngine"})," - The channel used to send messages to the consensus engine"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fxs"})," - Feature extensions that attach to this VM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"appSender"})," - Used to send messages to other nodes in the network"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"BlobVM upon initialization persists these fields in its own state to use them throughout the lifetime\nof its execution."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// implements "snowmanblock.ChainVM.common.VM"\nfunc (vm *VM) Initialize(\n\tctx *snow.Context,\n\tdbManager manager.Manager,\n\tgenesisBytes []byte,\n\tupgradeBytes []byte,\n\tconfigBytes []byte,\n\ttoEngine chan<- common.Message,\n\t_ []*common.Fx,\n\tappSender common.AppSender,\n) error {\n\tlog.Info("initializing blobvm", "version", version.Version)\n\n\t// Load config\n\tvm.config.SetDefaults()\n\tif len(configBytes) > 0 {\n\t\tif err := ejson.Unmarshal(configBytes, &vm.config); err != nil {\n\t\t\treturn fmt.Errorf("failed to unmarshal config %s: %w", string(configBytes), err)\n\t\t}\n\t}\n\n\tvm.ctx = ctx\n\tvm.db = dbManager.Current().Database\n\tvm.activityCache = make([]*chain.Activity, vm.config.ActivityCacheSize)\n\n\t// Init channels before initializing other structs\n\tvm.stop = make(chan struct{})\n\tvm.builderStop = make(chan struct{})\n\tvm.doneBuild = make(chan struct{})\n\tvm.doneGossip = make(chan struct{})\n\tvm.appSender = appSender\n\tvm.network = vm.NewPushNetwork()\n\n\tvm.blocks = &cache.LRU{Size: blocksLRUSize}\n\tvm.verifiedBlocks = make(map[ids.ID]*chain.StatelessBlock)\n\n\tvm.toEngine = toEngine\n\tvm.builder = vm.NewTimeBuilder()\n\n\t// Try to load last accepted\n\thas, err := chain.HasLastAccepted(vm.db)\n\tif err != nil {\n\t\tlog.Error("could not determine if have last accepted")\n\t\treturn err\n\t}\n\n\t// Parse genesis data\n\tvm.genesis = new(chain.Genesis)\n\tif err := ejson.Unmarshal(genesisBytes, vm.genesis); err != nil {\n\t\tlog.Error("could not unmarshal genesis bytes")\n\t\treturn err\n\t}\n\tif err := vm.genesis.Verify(); err != nil {\n\t\tlog.Error("genesis is invalid")\n\t\treturn err\n\t}\n\ttargetUnitsPerSecond := vm.genesis.TargetBlockSize / uint64(vm.genesis.TargetBlockRate)\n\tvm.targetRangeUnits = targetUnitsPerSecond * uint64(vm.genesis.LookbackWindow)\n\tlog.Debug("loaded genesis", "genesis", string(genesisBytes), "target range units", vm.targetRangeUnits)\n\n\tvm.mempool = mempool.New(vm.genesis, vm.config.MempoolSize)\n\n\tif has { //nolint:nestif\n\t\tblkID, err := chain.GetLastAccepted(vm.db)\n\t\tif err != nil {\n\t\t\tlog.Error("could not get last accepted", "err", err)\n\t\t\treturn err\n\t\t}\n\n\t\tblk, err := vm.GetStatelessBlock(blkID)\n\t\tif err != nil {\n\t\t\tlog.Error("could not load last accepted", "err", err)\n\t\t\treturn err\n\t\t}\n\n\t\tvm.preferred, vm.lastAccepted = blkID, blk\n\t\tlog.Info("initialized blobvm from last accepted", "block", blkID)\n\t} else {\n\t\tgenesisBlk, err := chain.ParseStatefulBlock(\n\t\t\tvm.genesis.StatefulBlock(),\n\t\t\tnil,\n\t\t\tchoices.Accepted,\n\t\t\tvm,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Error("unable to init genesis block", "err", err)\n\t\t\treturn err\n\t\t}\n\n\t\t// Set Balances\n\t\tif err := vm.genesis.Load(vm.db, vm.AirdropData); err != nil {\n\t\t\tlog.Error("could not set genesis allocation", "err", err)\n\t\t\treturn err\n\t\t}\n\n\t\tif err := chain.SetLastAccepted(vm.db, genesisBlk); err != nil {\n\t\t\tlog.Error("could not set genesis as last accepted", "err", err)\n\t\t\treturn err\n\t\t}\n\t\tgBlkID := genesisBlk.ID()\n\t\tvm.preferred, vm.lastAccepted = gBlkID, genesisBlk\n\t\tlog.Info("initialized blobvm from genesis", "block", gBlkID)\n\t}\n\tvm.AirdropData = nil\n'})}),"\n",(0,i.jsx)(n.p,{children:"After initializing its own state, BlobVM also starts asynchronous workers to build blocks and gossip\ntransactions to the rest of the network."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"\tgo vm.builder.Build()\n\tgo vm.builder.Gossip()\n\treturn nil\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"getblock",children:"GetBlock"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L318",children:(0,i.jsx)(n.code,{children:"GetBlock"})})," returns the block with\nthe provided ID."]}),"\n",(0,i.jsx)(n.p,{children:"GetBlock will attempt to fetch the given block from the database, and return an non-nil error if it\nwasn't able to get it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (vm *VM) GetBlock(id ids.ID) (snowman.Block, error) {\n\tb, err := vm.GetStatelessBlock(id)\n\tif err != nil {\n\t\tlog.Warn("failed to get block", "err", err)\n\t}\n\treturn b, err\n}\n'})}),"\n",(0,i.jsx)(n.h5,{id:"parseblock",children:"ParseBlock"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L353",children:(0,i.jsx)(n.code,{children:"ParseBlock"})})," deserializes a block."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (vm *VM) ParseBlock(source []byte) (snowman.Block, error) {\n\tnewBlk, err := chain.ParseBlock(\n\t\tsource,\n\t\tchoices.Processing,\n\t\tvm,\n\t)\n\tif err != nil {\n\t\tlog.Error("could not parse block", "err", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug("parsed block", "id", newBlk.ID())\n\n\t// If we have seen this block before, return it with the most\n\t// up-to-date info\n\tif oldBlk, err := vm.GetBlock(newBlk.ID()); err == nil {\n\t\tlog.Debug("returning previously parsed block", "id", oldBlk.ID())\n\t\treturn oldBlk, nil\n\t}\n\n\treturn newBlk, nil\n}\n'})}),"\n",(0,i.jsx)(n.h5,{id:"buildblock",children:"BuildBlock"}),"\n",(0,i.jsxs)(n.p,{children:["Lux consensus calls ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L377",children:(0,i.jsx)(n.code,{children:"BuildBlock"})}),"\nwhen it receives a notification from the VM that it has pending transactions that are ready to be\nissued into a block."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (vm *VM) BuildBlock() (snowman.Block, error) {\n\tlog.Debug("BuildBlock triggered")\n\tblk, err := chain.BuildBlock(vm, vm.preferred)\n\tvm.builder.HandleGenerateBlock()\n\tif err != nil {\n\t\tlog.Debug("BuildBlock failed", "error", err)\n\t\treturn nil, err\n\t}\n\tsblk, ok := blk.(*chain.StatelessBlock)\n\tif !ok {\n\t\treturn nil, fmt.Errorf("unexpected snowman.Block %T, expected *StatelessBlock", blk)\n\t}\n\n\tlog.Debug("BuildBlock success", "blkID", blk.ID(), "txs", len(sblk.Txs))\n\treturn blk, nil\n}\n'})}),"\n",(0,i.jsx)(n.h5,{id:"setpreference",children:"SetPreference"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L437",children:(0,i.jsx)(n.code,{children:"SetPreference"})})," sets the block ID\npreferred by this node. A node votes to accept or reject a block based on its current preference in consensus."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (vm *VM) SetPreference(id ids.ID) error {\n\tlog.Debug("set preference", "id", id)\n\tvm.preferred = id\n\treturn nil\n}\n'})}),"\n",(0,i.jsx)(n.h5,{id:"lastaccepted",children:"LastAccepted"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/vm/vm.go#L445",children:"LastAccepted"})," returns the block ID of\nthe block that was most recently accepted by this node."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func (vm *VM) LastAccepted() (ids.ID, error) {\n\treturn vm.lastAccepted.ID(), nil\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"cli",children:"CLI"}),"\n",(0,i.jsxs)(n.p,{children:["BlobVM implements a generic key-value store, but support to read and write arbitrary files into the\nBlobVM blockchain is implemented in the ",(0,i.jsx)(n.code,{children:"blob-cli"})]}),"\n",(0,i.jsxs)(n.p,{children:["To write a file, BlobVM breaks apart an arbitrarily large file into many small chunks. Each chunk is\nsubmitted to the VM in a ",(0,i.jsx)(n.code,{children:"SetTx"}),". A root key is generated which contains all of the hashes of the chunks."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func Upload(\n\tctx context.Context, cli client.Client, priv *ecdsa.PrivateKey,\n\tf io.Reader, chunkSize int,\n) (common.Hash, error) {\n\thashes := []common.Hash{}\n\tchunk := make([]byte, chunkSize)\n\tshouldExit := false\n\topts := []client.OpOption{client.WithPollTx()}\n\ttotalCost := uint64(0)\n\tuploaded := map[common.Hash]struct{}{}\n\tfor !shouldExit {\n\t\tread, err := f.Read(chunk)\n\t\tif errors.Is(err, io.EOF) || read == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn common.Hash{}, fmt.Errorf("%w: read error", err)\n\t\t}\n\t\tif read < chunkSize {\n\t\t\tshouldExit = true\n\t\t\tchunk = chunk[:read]\n\n\t\t\t// Use small file optimization\n\t\t\tif len(hashes) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tk := chain.ValueHash(chunk)\n\t\tif _, ok := uploaded[k]; ok {\n\t\t\tcolor.Yellow("already uploaded k=%s, skipping", k)\n\t\t} else if exists, _, _, err := cli.Resolve(ctx, k); err == nil && exists {\n\t\t\tcolor.Yellow("already on-chain k=%s, skipping", k)\n\t\t\tuploaded[k] = struct{}{}\n\t\t} else {\n\t\t\ttx := &chain.SetTx{\n\t\t\t\tBaseTx: &chain.BaseTx{},\n\t\t\t\tValue:  chunk,\n\t\t\t}\n\t\t\ttxID, cost, err := client.SignIssueRawTx(ctx, cli, tx, priv, opts...)\n\t\t\tif err != nil {\n\t\t\t\treturn common.Hash{}, err\n\t\t\t}\n\t\t\ttotalCost += cost\n\t\t\tcolor.Yellow("uploaded k=%s txID=%s cost=%d totalCost=%d", k, txID, cost, totalCost)\n\t\t\tuploaded[k] = struct{}{}\n\t\t}\n\t\thashes = append(hashes, k)\n\t}\n\n\tr := &Root{}\n\tif len(hashes) == 0 {\n\t\tif len(chunk) == 0 {\n\t\t\treturn common.Hash{}, ErrEmpty\n\t\t}\n\t\tr.Contents = chunk\n\t} else {\n\t\tr.Children = hashes\n\t}\n\n\trb, err := json.Marshal(r)\n\tif err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\trk := chain.ValueHash(rb)\n\ttx := &chain.SetTx{\n\t\tBaseTx: &chain.BaseTx{},\n\t\tValue:  rb,\n\t}\n\ttxID, cost, err := client.SignIssueRawTx(ctx, cli, tx, priv, opts...)\n\tif err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\ttotalCost += cost\n\tcolor.Yellow("uploaded root=%v txID=%s cost=%d totalCost=%d", rk, txID, cost, totalCost)\n\treturn rk, nil\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-1",children:"Example 1"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"blob-cli set-file ~/Downloads/computer.gif -> 6fe5a52f52b34fb1e07ba90bad47811c645176d0d49ef0c7a7b4b22013f676c8\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given the root hash, a file can be looked up by deserializing all of its children chunk values and\nreconstructing the original file."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// TODO: make multi-threaded\nfunc Download(ctx context.Context, cli client.Client, root common.Hash, f io.Writer) error {\n\texists, rb, _, err := cli.Resolve(ctx, root)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exists {\n\t\treturn fmt.Errorf("%w:%v", ErrMissing, root)\n\t}\n\tvar r Root\n\tif err := json.Unmarshal(rb, &r); err != nil {\n\t\treturn err\n\t}\n\n\t// Use small file optimization\n\tif contentLen := len(r.Contents); contentLen > 0 {\n\t\tif _, err := f.Write(r.Contents); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcolor.Yellow("downloaded root=%v size=%fKB", root, float64(contentLen)/units.KiB)\n\t\treturn nil\n\t}\n\n\tif len(r.Children) == 0 {\n\t\treturn ErrEmpty\n\t}\n\n\tamountDownloaded := 0\n\tfor _, h := range r.Children {\n\t\texists, b, _, err := cli.Resolve(ctx, h)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !exists {\n\t\t\treturn fmt.Errorf("%w:%s", ErrMissing, h)\n\t\t}\n\t\tif _, err := f.Write(b); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsize := len(b)\n\t\tcolor.Yellow("downloaded chunk=%v size=%fKB", h, float64(size)/units.KiB)\n\t\tamountDownloaded += size\n\t}\n\tcolor.Yellow("download complete root=%v size=%fMB", root, float64(amountDownloaded)/units.MiB)\n\treturn nil\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-2",children:"Example 2"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"blob-cli resolve-file 6fe5a52f52b34fb1e07ba90bad47811c645176d0d49ef0c7a7b4b22013f676c8 computer_copy.gif\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"This documentation covers concepts about Virtual Machine by walking through a VM that implements a\ndecentralized key-value store."}),"\n",(0,i.jsxs)(n.p,{children:["You can learn more about the BlobVM by referencing the ",(0,i.jsx)(n.a,{href:"https://github.com/luxfi/blobvm/blob/master/README.md",children:"\nREADME"})," in the GitHub repository."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},43540:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(48318);const s={},r=i.createContext(s);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);